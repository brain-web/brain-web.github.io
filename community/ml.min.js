!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t=t||self).ML={})}(this,function(exports){"use strict";const toString=Object.prototype.toString;function isAnyArray(t){return toString.call(t).endsWith("Array]")}var src=isAnyArray;function max(t){if(!src(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");for(var e=t[0],r=1;r<t.length;r++)t[r]>e&&(e=t[r]);return e}function min(t){if(!src(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");for(var e=t[0],r=1;r<t.length;r++)t[r]<e&&(e=t[r]);return e}function rescale(t){var e,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!src(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");if(void 0!==r.output){if(!src(r.output))throw new TypeError("output option must be an array if specified");e=r.output}else e=new Array(t.length);var n=min(t),i=max(t);if(n===i)throw new RangeError("minimum and maximum input values are equal. Cannot rescale a constant array");var o=r.min,s=void 0===o?r.autoMinMax?n:0:o,a=r.max,h=void 0===a?r.autoMinMax?i:1:a;if(s>=h)throw new RangeError("min option must be smaller than max option");for(var c=(h-s)/(i-n),u=0;u<t.length;u++)e[u]=(t[u]-n)*c+s;return e}function checkRowIndex(t,e,r){var n=r?t.rows:t.rows-1;if(e<0||e>n)throw new RangeError("Row index out of range")}function checkColumnIndex(t,e,r){var n=r?t.columns:t.columns-1;if(e<0||e>n)throw new RangeError("Column index out of range")}function checkRowVector(t,e){if(e.to1DArray&&(e=e.to1DArray()),e.length!==t.columns)throw new RangeError("vector size must be the same as the number of columns");return e}function checkColumnVector(t,e){if(e.to1DArray&&(e=e.to1DArray()),e.length!==t.rows)throw new RangeError("vector size must be the same as the number of rows");return e}function checkIndices(t,e,r){return{row:checkRowIndices(t,e),column:checkColumnIndices(t,r)}}function checkRowIndices(t,e){if("object"!=typeof e)throw new TypeError("unexpected type for row indices");if(e.some(e=>e<0||e>=t.rows))throw new RangeError("row indices are out of range");return Array.isArray(e)||(e=Array.from(e)),e}function checkColumnIndices(t,e){if("object"!=typeof e)throw new TypeError("unexpected type for column indices");if(e.some(e=>e<0||e>=t.columns))throw new RangeError("column indices are out of range");return Array.isArray(e)||(e=Array.from(e)),e}function checkRange(t,e,r,n,i){if(5!==arguments.length)throw new RangeError("expected 4 arguments");if(checkNumber("startRow",e),checkNumber("endRow",r),checkNumber("startColumn",n),checkNumber("endColumn",i),e>r||n>i||e<0||e>=t.rows||r<0||r>=t.rows||n<0||n>=t.columns||i<0||i>=t.columns)throw new RangeError("Submatrix indices are out of range")}function newArray(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;for(var r=[],n=0;n<t;n++)r.push(e);return r}function checkNumber(t,e){if("number"!=typeof e)throw new TypeError("".concat(t," must be a number"))}function sumByRow(t){for(var e=newArray(t.rows),r=0;r<t.rows;++r)for(var n=0;n<t.columns;++n)e[r]+=t.get(r,n);return e}function sumByColumn(t){for(var e=newArray(t.columns),r=0;r<t.rows;++r)for(var n=0;n<t.columns;++n)e[n]+=t.get(r,n);return e}function sumAll(t){for(var e=0,r=0;r<t.rows;r++)for(var n=0;n<t.columns;n++)e+=t.get(r,n);return e}function productByRow(t){for(var e=newArray(t.rows,1),r=0;r<t.rows;++r)for(var n=0;n<t.columns;++n)e[r]*=t.get(r,n);return e}function productByColumn(t){for(var e=newArray(t.columns,1),r=0;r<t.rows;++r)for(var n=0;n<t.columns;++n)e[n]*=t.get(r,n);return e}function productAll(t){for(var e=1,r=0;r<t.rows;r++)for(var n=0;n<t.columns;n++)e*=t.get(r,n);return e}function varianceByRow(t,e,r){const n=t.rows,i=t.columns,o=[];for(var s=0;s<n;s++){for(var a=0,h=0,c=0,u=0;u<i;u++)a+=c=t.get(s,u)-r[s],h+=c*c;e?o.push((h-a*a/i)/(i-1)):o.push((h-a*a/i)/i)}return o}function varianceByColumn(t,e,r){const n=t.rows,i=t.columns,o=[];for(var s=0;s<i;s++){for(var a=0,h=0,c=0,u=0;u<n;u++)a+=c=t.get(u,s)-r[s],h+=c*c;e?o.push((h-a*a/n)/(n-1)):o.push((h-a*a/n)/n)}return o}function varianceAll(t,e,r){const n=t.rows,i=t.columns,o=n*i;for(var s=0,a=0,h=0,c=0;c<n;c++)for(var u=0;u<i;u++)s+=h=t.get(c,u)-r,a+=h*h;return e?(a-s*s/o)/(o-1):(a-s*s/o)/o}function centerByRow(t,e){for(let r=0;r<t.rows;r++)for(let n=0;n<t.columns;n++)t.set(r,n,t.get(r,n)-e[r])}function centerByColumn(t,e){for(let r=0;r<t.rows;r++)for(let n=0;n<t.columns;n++)t.set(r,n,t.get(r,n)-e[n])}function centerAll(t,e){for(let r=0;r<t.rows;r++)for(let n=0;n<t.columns;n++)t.set(r,n,t.get(r,n)-e)}function getScaleByRow(t){const e=[];for(let r=0;r<t.rows;r++){let n=0;for(let e=0;e<t.columns;e++)n+=Math.pow(t.get(r,e),2)/(t.columns-1);e.push(Math.sqrt(n))}return e}function scaleByRow(t,e){for(let r=0;r<t.rows;r++)for(let n=0;n<t.columns;n++)t.set(r,n,t.get(r,n)/e[r])}function getScaleByColumn(t){const e=[];for(let r=0;r<t.columns;r++){let n=0;for(let e=0;e<t.rows;e++)n+=Math.pow(t.get(e,r),2)/(t.rows-1);e.push(Math.sqrt(n))}return e}function scaleByColumn(t,e){for(let r=0;r<t.rows;r++)for(let n=0;n<t.columns;n++)t.set(r,n,t.get(r,n)/e[n])}function getScaleAll(t){const e=t.size-1;let r=0;for(let n=0;n<t.columns;n++)for(let i=0;i<t.rows;i++)r+=Math.pow(t.get(i,n),2)/e;return Math.sqrt(r)}function scaleAll(t,e){for(let r=0;r<t.rows;r++)for(let n=0;n<t.columns;n++)t.set(r,n,t.get(r,n)/e)}function inspectMatrix(){const t=" ".repeat(2),e=" ".repeat(4);return"".concat(this.constructor.name," {\n").concat(t,"[\n").concat(e).concat(inspectData(this,e),"\n").concat(t,"]\n").concat(t,"rows: ").concat(this.rows,"\n").concat(t,"columns: ").concat(this.columns,"\n}")}const maxRows=15,maxColumns=10,maxNumSize=8;function inspectData(t,e){const{rows:r,columns:n}=t,i=Math.min(r,maxRows),o=Math.min(n,maxColumns),s=[];for(var a=0;a<i;a++){let e=[];for(var h=0;h<o;h++)e.push(formatNumber(t.get(a,h)));s.push("".concat(e.join(" ")))}return o!==n&&(s[s.length-1]+=" ... ".concat(n-maxColumns," more columns")),i!==r&&s.push("... ".concat(r-maxRows," more rows")),s.join("\n".concat(e))}function formatNumber(t){const e=String(t);if(e.length<=maxNumSize)return e.padEnd(maxNumSize," ");const r=t.toPrecision(maxNumSize-2);if(r.length<=maxNumSize)return r;const n=t.toExponential(maxNumSize-2),i=n.indexOf("e"),o=n.substring(i);return n.substring(0,maxNumSize-o.length)+o}function installMathOperations(t,e){t.prototype.add=function(t){return"number"==typeof t?this.addS(t):this.addM(t)},t.prototype.addS=function(t){for(var e=0;e<this.rows;e++)for(var r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)+t);return this},t.prototype.addM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(var r=0;r<this.rows;r++)for(var n=0;n<this.columns;n++)this.set(r,n,this.get(r,n)+t.get(r,n));return this},t.add=function(t,r){return new e(t).add(r)},t.prototype.sub=function(t){return"number"==typeof t?this.subS(t):this.subM(t)},t.prototype.subS=function(t){for(var e=0;e<this.rows;e++)for(var r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)-t);return this},t.prototype.subM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(var r=0;r<this.rows;r++)for(var n=0;n<this.columns;n++)this.set(r,n,this.get(r,n)-t.get(r,n));return this},t.sub=function(t,r){return new e(t).sub(r)},t.prototype.subtract=t.prototype.sub,t.prototype.subtractS=t.prototype.subS,t.prototype.subtractM=t.prototype.subM,t.subtract=t.sub,t.prototype.mul=function(t){return"number"==typeof t?this.mulS(t):this.mulM(t)},t.prototype.mulS=function(t){for(var e=0;e<this.rows;e++)for(var r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t);return this},t.prototype.mulM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(var r=0;r<this.rows;r++)for(var n=0;n<this.columns;n++)this.set(r,n,this.get(r,n)*t.get(r,n));return this},t.mul=function(t,r){return new e(t).mul(r)},t.prototype.multiply=t.prototype.mul,t.prototype.multiplyS=t.prototype.mulS,t.prototype.multiplyM=t.prototype.mulM,t.multiply=t.mul,t.prototype.div=function(t){return"number"==typeof t?this.divS(t):this.divM(t)},t.prototype.divS=function(t){for(var e=0;e<this.rows;e++)for(var r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)/t);return this},t.prototype.divM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(var r=0;r<this.rows;r++)for(var n=0;n<this.columns;n++)this.set(r,n,this.get(r,n)/t.get(r,n));return this},t.div=function(t,r){return new e(t).div(r)},t.prototype.divide=t.prototype.div,t.prototype.divideS=t.prototype.divS,t.prototype.divideM=t.prototype.divM,t.divide=t.div,t.prototype.mod=function(t){return"number"==typeof t?this.modS(t):this.modM(t)},t.prototype.modS=function(t){for(var e=0;e<this.rows;e++)for(var r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)%t);return this},t.prototype.modM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(var r=0;r<this.rows;r++)for(var n=0;n<this.columns;n++)this.set(r,n,this.get(r,n)%t.get(r,n));return this},t.mod=function(t,r){return new e(t).mod(r)},t.prototype.modulus=t.prototype.mod,t.prototype.modulusS=t.prototype.modS,t.prototype.modulusM=t.prototype.modM,t.modulus=t.mod,t.prototype.and=function(t){return"number"==typeof t?this.andS(t):this.andM(t)},t.prototype.andS=function(t){for(var e=0;e<this.rows;e++)for(var r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)&t);return this},t.prototype.andM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(var r=0;r<this.rows;r++)for(var n=0;n<this.columns;n++)this.set(r,n,this.get(r,n)&t.get(r,n));return this},t.and=function(t,r){return new e(t).and(r)},t.prototype.or=function(t){return"number"==typeof t?this.orS(t):this.orM(t)},t.prototype.orS=function(t){for(var e=0;e<this.rows;e++)for(var r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)|t);return this},t.prototype.orM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(var r=0;r<this.rows;r++)for(var n=0;n<this.columns;n++)this.set(r,n,this.get(r,n)|t.get(r,n));return this},t.or=function(t,r){return new e(t).or(r)},t.prototype.xor=function(t){return"number"==typeof t?this.xorS(t):this.xorM(t)},t.prototype.xorS=function(t){for(var e=0;e<this.rows;e++)for(var r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)^t);return this},t.prototype.xorM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(var r=0;r<this.rows;r++)for(var n=0;n<this.columns;n++)this.set(r,n,this.get(r,n)^t.get(r,n));return this},t.xor=function(t,r){return new e(t).xor(r)},t.prototype.leftShift=function(t){return"number"==typeof t?this.leftShiftS(t):this.leftShiftM(t)},t.prototype.leftShiftS=function(t){for(var e=0;e<this.rows;e++)for(var r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)<<t);return this},t.prototype.leftShiftM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(var r=0;r<this.rows;r++)for(var n=0;n<this.columns;n++)this.set(r,n,this.get(r,n)<<t.get(r,n));return this},t.leftShift=function(t,r){return new e(t).leftShift(r)},t.prototype.signPropagatingRightShift=function(t){return"number"==typeof t?this.signPropagatingRightShiftS(t):this.signPropagatingRightShiftM(t)},t.prototype.signPropagatingRightShiftS=function(t){for(var e=0;e<this.rows;e++)for(var r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)>>t);return this},t.prototype.signPropagatingRightShiftM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(var r=0;r<this.rows;r++)for(var n=0;n<this.columns;n++)this.set(r,n,this.get(r,n)>>t.get(r,n));return this},t.signPropagatingRightShift=function(t,r){return new e(t).signPropagatingRightShift(r)},t.prototype.rightShift=function(t){return"number"==typeof t?this.rightShiftS(t):this.rightShiftM(t)},t.prototype.rightShiftS=function(t){for(var e=0;e<this.rows;e++)for(var r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)>>>t);return this},t.prototype.rightShiftM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(var r=0;r<this.rows;r++)for(var n=0;n<this.columns;n++)this.set(r,n,this.get(r,n)>>>t.get(r,n));return this},t.rightShift=function(t,r){return new e(t).rightShift(r)},t.prototype.zeroFillRightShift=t.prototype.rightShift,t.prototype.zeroFillRightShiftS=t.prototype.rightShiftS,t.prototype.zeroFillRightShiftM=t.prototype.rightShiftM,t.zeroFillRightShift=t.rightShift,t.prototype.not=function(){for(var t=0;t<this.rows;t++)for(var e=0;e<this.columns;e++)this.set(t,e,~this.get(t,e));return this},t.not=function(t){return new e(t).not()},t.prototype.abs=function(){for(var t=0;t<this.rows;t++)for(var e=0;e<this.columns;e++)this.set(t,e,Math.abs(this.get(t,e)));return this},t.abs=function(t){return new e(t).abs()},t.prototype.acos=function(){for(var t=0;t<this.rows;t++)for(var e=0;e<this.columns;e++)this.set(t,e,Math.acos(this.get(t,e)));return this},t.acos=function(t){return new e(t).acos()},t.prototype.acosh=function(){for(var t=0;t<this.rows;t++)for(var e=0;e<this.columns;e++)this.set(t,e,Math.acosh(this.get(t,e)));return this},t.acosh=function(t){return new e(t).acosh()},t.prototype.asin=function(){for(var t=0;t<this.rows;t++)for(var e=0;e<this.columns;e++)this.set(t,e,Math.asin(this.get(t,e)));return this},t.asin=function(t){return new e(t).asin()},t.prototype.asinh=function(){for(var t=0;t<this.rows;t++)for(var e=0;e<this.columns;e++)this.set(t,e,Math.asinh(this.get(t,e)));return this},t.asinh=function(t){return new e(t).asinh()},t.prototype.atan=function(){for(var t=0;t<this.rows;t++)for(var e=0;e<this.columns;e++)this.set(t,e,Math.atan(this.get(t,e)));return this},t.atan=function(t){return new e(t).atan()},t.prototype.atanh=function(){for(var t=0;t<this.rows;t++)for(var e=0;e<this.columns;e++)this.set(t,e,Math.atanh(this.get(t,e)));return this},t.atanh=function(t){return new e(t).atanh()},t.prototype.cbrt=function(){for(var t=0;t<this.rows;t++)for(var e=0;e<this.columns;e++)this.set(t,e,Math.cbrt(this.get(t,e)));return this},t.cbrt=function(t){return new e(t).cbrt()},t.prototype.ceil=function(){for(var t=0;t<this.rows;t++)for(var e=0;e<this.columns;e++)this.set(t,e,Math.ceil(this.get(t,e)));return this},t.ceil=function(t){return new e(t).ceil()},t.prototype.clz32=function(){for(var t=0;t<this.rows;t++)for(var e=0;e<this.columns;e++)this.set(t,e,Math.clz32(this.get(t,e)));return this},t.clz32=function(t){return new e(t).clz32()},t.prototype.cos=function(){for(var t=0;t<this.rows;t++)for(var e=0;e<this.columns;e++)this.set(t,e,Math.cos(this.get(t,e)));return this},t.cos=function(t){return new e(t).cos()},t.prototype.cosh=function(){for(var t=0;t<this.rows;t++)for(var e=0;e<this.columns;e++)this.set(t,e,Math.cosh(this.get(t,e)));return this},t.cosh=function(t){return new e(t).cosh()},t.prototype.exp=function(){for(var t=0;t<this.rows;t++)for(var e=0;e<this.columns;e++)this.set(t,e,Math.exp(this.get(t,e)));return this},t.exp=function(t){return new e(t).exp()},t.prototype.expm1=function(){for(var t=0;t<this.rows;t++)for(var e=0;e<this.columns;e++)this.set(t,e,Math.expm1(this.get(t,e)));return this},t.expm1=function(t){return new e(t).expm1()},t.prototype.floor=function(){for(var t=0;t<this.rows;t++)for(var e=0;e<this.columns;e++)this.set(t,e,Math.floor(this.get(t,e)));return this},t.floor=function(t){return new e(t).floor()},t.prototype.fround=function(){for(var t=0;t<this.rows;t++)for(var e=0;e<this.columns;e++)this.set(t,e,Math.fround(this.get(t,e)));return this},t.fround=function(t){return new e(t).fround()},t.prototype.log=function(){for(var t=0;t<this.rows;t++)for(var e=0;e<this.columns;e++)this.set(t,e,Math.log(this.get(t,e)));return this},t.log=function(t){return new e(t).log()},t.prototype.log1p=function(){for(var t=0;t<this.rows;t++)for(var e=0;e<this.columns;e++)this.set(t,e,Math.log1p(this.get(t,e)));return this},t.log1p=function(t){return new e(t).log1p()},t.prototype.log10=function(){for(var t=0;t<this.rows;t++)for(var e=0;e<this.columns;e++)this.set(t,e,Math.log10(this.get(t,e)));return this},t.log10=function(t){return new e(t).log10()},t.prototype.log2=function(){for(var t=0;t<this.rows;t++)for(var e=0;e<this.columns;e++)this.set(t,e,Math.log2(this.get(t,e)));return this},t.log2=function(t){return new e(t).log2()},t.prototype.round=function(){for(var t=0;t<this.rows;t++)for(var e=0;e<this.columns;e++)this.set(t,e,Math.round(this.get(t,e)));return this},t.round=function(t){return new e(t).round()},t.prototype.sign=function(){for(var t=0;t<this.rows;t++)for(var e=0;e<this.columns;e++)this.set(t,e,Math.sign(this.get(t,e)));return this},t.sign=function(t){return new e(t).sign()},t.prototype.sin=function(){for(var t=0;t<this.rows;t++)for(var e=0;e<this.columns;e++)this.set(t,e,Math.sin(this.get(t,e)));return this},t.sin=function(t){return new e(t).sin()},t.prototype.sinh=function(){for(var t=0;t<this.rows;t++)for(var e=0;e<this.columns;e++)this.set(t,e,Math.sinh(this.get(t,e)));return this},t.sinh=function(t){return new e(t).sinh()},t.prototype.sqrt=function(){for(var t=0;t<this.rows;t++)for(var e=0;e<this.columns;e++)this.set(t,e,Math.sqrt(this.get(t,e)));return this},t.sqrt=function(t){return new e(t).sqrt()},t.prototype.tan=function(){for(var t=0;t<this.rows;t++)for(var e=0;e<this.columns;e++)this.set(t,e,Math.tan(this.get(t,e)));return this},t.tan=function(t){return new e(t).tan()},t.prototype.tanh=function(){for(var t=0;t<this.rows;t++)for(var e=0;e<this.columns;e++)this.set(t,e,Math.tanh(this.get(t,e)));return this},t.tanh=function(t){return new e(t).tanh()},t.prototype.trunc=function(){for(var t=0;t<this.rows;t++)for(var e=0;e<this.columns;e++)this.set(t,e,Math.trunc(this.get(t,e)));return this},t.trunc=function(t){return new e(t).trunc()},t.pow=function(t,r){return new e(t).pow(r)},t.prototype.pow=function(t){return"number"==typeof t?this.powS(t):this.powM(t)},t.prototype.powS=function(t){for(var e=0;e<this.rows;e++)for(var r=0;r<this.columns;r++)this.set(e,r,Math.pow(this.get(e,r),t));return this},t.prototype.powM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(var r=0;r<this.rows;r++)for(var n=0;n<this.columns;n++)this.set(r,n,Math.pow(this.get(r,n),t.get(r,n)));return this}}class AbstractMatrix{static from1DArray(t,e,r){if(t*e!==r.length)throw new RangeError("data length does not match given dimensions");for(var n=new Matrix(t,e),i=0;i<t;i++)for(var o=0;o<e;o++)n.set(i,o,r[i*e+o]);return n}static rowVector(t){for(var e=new Matrix(1,t.length),r=0;r<t.length;r++)e.set(0,r,t[r]);return e}static columnVector(t){for(var e=new Matrix(t.length,1),r=0;r<t.length;r++)e.set(r,0,t[r]);return e}static zeros(t,e){return new Matrix(t,e)}static ones(t,e){return new Matrix(t,e).fill(1)}static rand(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if("object"!=typeof r)throw new TypeError("options must be an object");const{random:n=Math.random}=r;for(var i=new Matrix(t,e),o=0;o<t;o++)for(var s=0;s<e;s++)i.set(o,s,n());return i}static randInt(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if("object"!=typeof r)throw new TypeError("options must be an object");const{min:n=0,max:i=1e3,random:o=Math.random}=r;if(!Number.isInteger(n))throw new TypeError("min must be an integer");if(!Number.isInteger(i))throw new TypeError("max must be an integer");if(n>=i)throw new RangeError("min must be smaller than max");for(var s=i-n,a=new Matrix(t,e),h=0;h<t;h++)for(var c=0;c<e;c++){var u=n+Math.round(o()*s);a.set(h,c,u)}return a}static eye(t,e,r){void 0===e&&(e=t),void 0===r&&(r=1);for(var n=Math.min(t,e),i=this.zeros(t,e),o=0;o<n;o++)i.set(o,o,r);return i}static diag(t,e,r){var n=t.length;void 0===e&&(e=n),void 0===r&&(r=e);for(var i=Math.min(n,e,r),o=this.zeros(e,r),s=0;s<i;s++)o.set(s,s,t[s]);return o}static min(t,e){t=this.checkMatrix(t),e=this.checkMatrix(e);for(var r=t.rows,n=t.columns,i=new Matrix(r,n),o=0;o<r;o++)for(var s=0;s<n;s++)i.set(o,s,Math.min(t.get(o,s),e.get(o,s)));return i}static max(t,e){t=this.checkMatrix(t),e=this.checkMatrix(e);for(var r=t.rows,n=t.columns,i=new this(r,n),o=0;o<r;o++)for(var s=0;s<n;s++)i.set(o,s,Math.max(t.get(o,s),e.get(o,s)));return i}static checkMatrix(t){return AbstractMatrix.isMatrix(t)?t:new Matrix(t)}static isMatrix(t){return null!=t&&"Matrix"===t.klass}get size(){return this.rows*this.columns}apply(t){if("function"!=typeof t)throw new TypeError("callback must be a function");for(var e=0;e<this.rows;e++)for(var r=0;r<this.columns;r++)t.call(this,e,r);return this}to1DArray(){for(var t=[],e=0;e<this.rows;e++)for(var r=0;r<this.columns;r++)t.push(this.get(e,r));return t}to2DArray(){for(var t=[],e=0;e<this.rows;e++){t.push([]);for(var r=0;r<this.columns;r++)t[e].push(this.get(e,r))}return t}toJSON(){return this.to2DArray()}isRowVector(){return 1===this.rows}isColumnVector(){return 1===this.columns}isVector(){return 1===this.rows||1===this.columns}isSquare(){return this.rows===this.columns}isSymmetric(){if(this.isSquare()){for(var t=0;t<this.rows;t++)for(var e=0;e<=t;e++)if(this.get(t,e)!==this.get(e,t))return!1;return!0}return!1}isEchelonForm(){let t=0,e=0,r=-1,n=!0,i=!1;for(;t<this.rows&&n;){for(e=0,i=!1;e<this.columns&&!1===i;)0===this.get(t,e)?e++:1===this.get(t,e)&&e>r?(i=!0,r=e):(n=!1,i=!0);t++}return n}isReducedEchelonForm(){let t=0,e=0,r=-1,n=!0,i=!1;for(;t<this.rows&&n;){for(e=0,i=!1;e<this.columns&&!1===i;)0===this.get(t,e)?e++:1===this.get(t,e)&&e>r?(i=!0,r=e):(n=!1,i=!0);for(let r=e+1;r<this.rows;r++)0!==this.get(t,r)&&(n=!1);t++}return n}echelonForm(){let t=this.clone(),e=0,r=0;for(;e<t.rows&&r<t.columns;){let n=e;for(let i=e;i<t.rows;i++)t.get(i,r)>t.get(n,r)&&(n=i);if(0===t.get(n,r))r++;else{t.swapRows(e,n);let i=t.get(e,r);for(let n=r;n<t.columns;n++)t.set(e,n,t.get(e,n)/i);for(let n=e+1;n<t.rows;n++){let i=t.get(n,r)/t.get(e,r);t.set(n,r,0);for(let o=r+1;o<t.columns;o++)t.set(n,o,t.get(n,o)-t.get(e,o)*i)}e++,r++}}return t}reducedEchelonForm(){let t=this.echelonForm(),e=t.columns,r=t.rows,n=r-1;for(;n>=0;)if(0===t.maxRow(n))n--;else{let i=0,o=!1;for(;i<r&&!1===o;)1===t.get(n,i)?o=!0:i++;for(let r=0;r<n;r++){let o=t.get(r,i);for(let s=i;s<e;s++){let e=t.get(r,s)-o*t.get(n,s);t.set(r,s,e)}}n--}return t}set(){throw new Error("set method is unimplemented")}get(){throw new Error("get method is unimplemented")}repeat(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if("object"!=typeof t)throw new TypeError("options must be an object");const{rows:e=1,columns:r=1}=t;if(!Number.isInteger(e)||e<=0)throw new TypeError("rows must be a positive integer");if(!Number.isInteger(r)||r<=0)throw new TypeError("columns must be a positive integer");for(var n=new Matrix(this.rows*e,this.columns*r),i=0;i<e;i++)for(var o=0;o<r;o++)n.setSubMatrix(this,this.rows*i,this.columns*o);return n}fill(t){for(var e=0;e<this.rows;e++)for(var r=0;r<this.columns;r++)this.set(e,r,t);return this}neg(){return this.mulS(-1)}getRow(t){checkRowIndex(this,t);for(var e=[],r=0;r<this.columns;r++)e.push(this.get(t,r));return e}getRowVector(t){return Matrix.rowVector(this.getRow(t))}setRow(t,e){checkRowIndex(this,t),e=checkRowVector(this,e);for(var r=0;r<this.columns;r++)this.set(t,r,e[r]);return this}swapRows(t,e){checkRowIndex(this,t),checkRowIndex(this,e);for(var r=0;r<this.columns;r++){var n=this.get(t,r);this.set(t,r,this.get(e,r)),this.set(e,r,n)}return this}getColumn(t){checkColumnIndex(this,t);for(var e=[],r=0;r<this.rows;r++)e.push(this.get(r,t));return e}getColumnVector(t){return Matrix.columnVector(this.getColumn(t))}setColumn(t,e){checkColumnIndex(this,t),e=checkColumnVector(this,e);for(var r=0;r<this.rows;r++)this.set(r,t,e[r]);return this}swapColumns(t,e){checkColumnIndex(this,t),checkColumnIndex(this,e);for(var r=0;r<this.rows;r++){var n=this.get(r,t);this.set(r,t,this.get(r,e)),this.set(r,e,n)}return this}addRowVector(t){t=checkRowVector(this,t);for(var e=0;e<this.rows;e++)for(var r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)+t[r]);return this}subRowVector(t){t=checkRowVector(this,t);for(var e=0;e<this.rows;e++)for(var r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)-t[r]);return this}mulRowVector(t){t=checkRowVector(this,t);for(var e=0;e<this.rows;e++)for(var r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t[r]);return this}divRowVector(t){t=checkRowVector(this,t);for(var e=0;e<this.rows;e++)for(var r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)/t[r]);return this}addColumnVector(t){t=checkColumnVector(this,t);for(var e=0;e<this.rows;e++)for(var r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)+t[e]);return this}subColumnVector(t){t=checkColumnVector(this,t);for(var e=0;e<this.rows;e++)for(var r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)-t[e]);return this}mulColumnVector(t){t=checkColumnVector(this,t);for(var e=0;e<this.rows;e++)for(var r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t[e]);return this}divColumnVector(t){t=checkColumnVector(this,t);for(var e=0;e<this.rows;e++)for(var r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)/t[e]);return this}mulRow(t,e){checkRowIndex(this,t);for(var r=0;r<this.columns;r++)this.set(t,r,this.get(t,r)*e);return this}mulColumn(t,e){checkColumnIndex(this,t);for(var r=0;r<this.rows;r++)this.set(r,t,this.get(r,t)*e);return this}max(){for(var t=this.get(0,0),e=0;e<this.rows;e++)for(var r=0;r<this.columns;r++)this.get(e,r)>t&&(t=this.get(e,r));return t}maxIndex(){for(var t=this.get(0,0),e=[0,0],r=0;r<this.rows;r++)for(var n=0;n<this.columns;n++)this.get(r,n)>t&&(t=this.get(r,n),e[0]=r,e[1]=n);return e}min(){for(var t=this.get(0,0),e=0;e<this.rows;e++)for(var r=0;r<this.columns;r++)this.get(e,r)<t&&(t=this.get(e,r));return t}minIndex(){for(var t=this.get(0,0),e=[0,0],r=0;r<this.rows;r++)for(var n=0;n<this.columns;n++)this.get(r,n)<t&&(t=this.get(r,n),e[0]=r,e[1]=n);return e}maxRow(t){checkRowIndex(this,t);for(var e=this.get(t,0),r=1;r<this.columns;r++)this.get(t,r)>e&&(e=this.get(t,r));return e}maxRowIndex(t){checkRowIndex(this,t);for(var e=this.get(t,0),r=[t,0],n=1;n<this.columns;n++)this.get(t,n)>e&&(e=this.get(t,n),r[1]=n);return r}minRow(t){checkRowIndex(this,t);for(var e=this.get(t,0),r=1;r<this.columns;r++)this.get(t,r)<e&&(e=this.get(t,r));return e}minRowIndex(t){checkRowIndex(this,t);for(var e=this.get(t,0),r=[t,0],n=1;n<this.columns;n++)this.get(t,n)<e&&(e=this.get(t,n),r[1]=n);return r}maxColumn(t){checkColumnIndex(this,t);for(var e=this.get(0,t),r=1;r<this.rows;r++)this.get(r,t)>e&&(e=this.get(r,t));return e}maxColumnIndex(t){checkColumnIndex(this,t);for(var e=this.get(0,t),r=[0,t],n=1;n<this.rows;n++)this.get(n,t)>e&&(e=this.get(n,t),r[0]=n);return r}minColumn(t){checkColumnIndex(this,t);for(var e=this.get(0,t),r=1;r<this.rows;r++)this.get(r,t)<e&&(e=this.get(r,t));return e}minColumnIndex(t){checkColumnIndex(this,t);for(var e=this.get(0,t),r=[0,t],n=1;n<this.rows;n++)this.get(n,t)<e&&(e=this.get(n,t),r[0]=n);return r}diag(){for(var t=Math.min(this.rows,this.columns),e=[],r=0;r<t;r++)e.push(this.get(r,r));return e}norm(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"frobenius";var e=0;if("max"===t)return this.max();if("frobenius"===t){for(var r=0;r<this.rows;r++)for(var n=0;n<this.columns;n++)e+=this.get(r,n)*this.get(r,n);return Math.sqrt(e)}throw new RangeError("unknown norm type: ".concat(t))}cumulativeSum(){for(var t=0,e=0;e<this.rows;e++)for(var r=0;r<this.columns;r++)t+=this.get(e,r),this.set(e,r,t);return this}dot(t){AbstractMatrix.isMatrix(t)&&(t=t.to1DArray());var e=this.to1DArray();if(e.length!==t.length)throw new RangeError("vectors do not have the same size");for(var r=0,n=0;n<e.length;n++)r+=e[n]*t[n];return r}mmul(t){t=Matrix.checkMatrix(t);for(var e=this.rows,r=this.columns,n=t.columns,i=new Matrix(e,n),o=new Float64Array(r),s=0;s<n;s++){for(var a=0;a<r;a++)o[a]=t.get(a,s);for(var h=0;h<e;h++){var c=0;for(a=0;a<r;a++)c+=this.get(h,a)*o[a];i.set(h,s,c)}}return i}strassen2x2(t){t=Matrix.checkMatrix(t);var e=new Matrix(2,2);const r=this.get(0,0),n=t.get(0,0),i=this.get(0,1),o=t.get(0,1),s=this.get(1,0),a=t.get(1,0),h=this.get(1,1),c=t.get(1,1),u=(r+h)*(n+c),l=(s+h)*n,f=r*(o-c),m=h*(a-n),g=(r+i)*c,d=u+m-g+(i-h)*(a+c),p=f+g,w=l+m,v=u-l+f+(s-r)*(n+o);return e.set(0,0,d),e.set(0,1,p),e.set(1,0,w),e.set(1,1,v),e}strassen3x3(t){t=Matrix.checkMatrix(t);var e=new Matrix(3,3);const r=this.get(0,0),n=this.get(0,1),i=this.get(0,2),o=this.get(1,0),s=this.get(1,1),a=this.get(1,2),h=this.get(2,0),c=this.get(2,1),u=this.get(2,2),l=t.get(0,0),f=t.get(0,1),m=t.get(0,2),g=t.get(1,0),d=t.get(1,1),p=t.get(1,2),w=t.get(2,0),v=t.get(2,1),x=t.get(2,2),y=(r-o)*(-f+d),M=(-r+o+s)*(l-f+d),b=(o+s)*(-l+f),S=r*l,A=(-r+h+c)*(l-m+p),E=(-r+h)*(m-p),R=(h+c)*(-l+m),T=(-i+c+u)*(d+w-v),k=(i-u)*(d-v),N=i*w,C=(c+u)*(-w+v),I=(-i+s+a)*(p+w-x),L=(i-a)*(p-x),F=(s+a)*(-w+x),O=S+N+n*g,P=(r+n+i-o-s-c-u)*d+M+b+S+T+N+C,V=S+A+R+(r+n+i-s-a-h-c)*p+N+I+F,D=y+s*(-l+f+g-d-p-w+x)+M+S+N+I+L,z=y+M+b+S+a*v,_=N+I+L+F+o*m,q=S+A+E+c*(-l+m+g-d-p-w+v)+T+k+N,$=T+k+N+C+h*f,U=S+A+E+R+u*x;return e.set(0,0,O),e.set(0,1,P),e.set(0,2,V),e.set(1,0,D),e.set(1,1,z),e.set(1,2,_),e.set(2,0,q),e.set(2,1,$),e.set(2,2,U),e}mmulStrassen(t){t=Matrix.checkMatrix(t);var e=this.clone(),r=e.rows,n=e.columns,i=t.rows,o=t.columns;function s(t,e,r){var n=t.rows,i=t.columns;if(n===e&&i===r)return t;var o=AbstractMatrix.zeros(e,r);return o=o.setSubMatrix(t,0,0)}n!==i&&console.warn("Multiplying ".concat(r," x ").concat(n," and ").concat(i," x ").concat(o," matrix: dimensions do not match."));var a=Math.max(r,i),h=Math.max(n,o);return function t(e,r,n,i){if(n<=512||i<=512)return e.mmul(r);n%2==1&&i%2==1?(e=s(e,n+1,i+1),r=s(r,n+1,i+1)):n%2==1?(e=s(e,n+1,i),r=s(r,n+1,i)):i%2==1&&(e=s(e,n,i+1),r=s(r,n,i+1));var o=parseInt(e.rows/2,10),a=parseInt(e.columns/2,10),h=e.subMatrix(0,o-1,0,a-1),c=r.subMatrix(0,o-1,0,a-1),u=e.subMatrix(0,o-1,a,e.columns-1),l=r.subMatrix(0,o-1,a,r.columns-1),f=e.subMatrix(o,e.rows-1,0,a-1),m=r.subMatrix(o,r.rows-1,0,a-1),g=e.subMatrix(o,e.rows-1,a,e.columns-1),d=r.subMatrix(o,r.rows-1,a,r.columns-1),p=t(AbstractMatrix.add(h,g),AbstractMatrix.add(c,d),o,a),w=t(AbstractMatrix.add(f,g),c,o,a),v=t(h,AbstractMatrix.sub(l,d),o,a),x=t(g,AbstractMatrix.sub(m,c),o,a),y=t(AbstractMatrix.add(h,u),d,o,a),M=t(AbstractMatrix.sub(f,h),AbstractMatrix.add(c,l),o,a),b=t(AbstractMatrix.sub(u,g),AbstractMatrix.add(m,d),o,a),S=AbstractMatrix.add(p,x);S.sub(y),S.add(b);var A=AbstractMatrix.add(v,y),E=AbstractMatrix.add(w,x),R=AbstractMatrix.sub(p,w);R.add(v),R.add(M);var T=AbstractMatrix.zeros(2*S.rows,2*S.columns);return(T=(T=(T=(T=T.setSubMatrix(S,0,0)).setSubMatrix(A,S.rows,0)).setSubMatrix(E,0,S.columns)).setSubMatrix(R,S.rows,S.columns)).subMatrix(0,n-1,0,i-1)}(e=s(e,a,h),t=s(t,a,h),a,h)}scaleRows(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if("object"!=typeof t)throw new TypeError("options must be an object");const{min:e=0,max:r=1}=t;if(!Number.isFinite(e))throw new TypeError("min must be a number");if(!Number.isFinite(r))throw new TypeError("max must be a number");if(e>=r)throw new RangeError("min must be smaller than max");for(var n=new Matrix(this.rows,this.columns),i=0;i<this.rows;i++){const t=this.getRow(i);rescale(t,{min:e,max:r,output:t}),n.setRow(i,t)}return n}scaleColumns(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if("object"!=typeof t)throw new TypeError("options must be an object");const{min:e=0,max:r=1}=t;if(!Number.isFinite(e))throw new TypeError("min must be a number");if(!Number.isFinite(r))throw new TypeError("max must be a number");if(e>=r)throw new RangeError("min must be smaller than max");for(var n=new Matrix(this.rows,this.columns),i=0;i<this.columns;i++){const t=this.getColumn(i);rescale(t,{min:e,max:r,output:t}),n.setColumn(i,t)}return n}flipRows(){const t=Math.ceil(this.columns/2);for(var e=0;e<this.rows;e++)for(var r=0;r<t;r++){var n=this.get(e,r),i=this.get(e,this.columns-1-r);this.set(e,r,i),this.set(e,this.columns-1-r,n)}return this}flipColumns(){const t=Math.ceil(this.rows/2);for(var e=0;e<this.columns;e++)for(var r=0;r<t;r++){var n=this.get(r,e),i=this.get(this.rows-1-r,e);this.set(r,e,i),this.set(this.rows-1-r,e,n)}return this}kroneckerProduct(t){t=Matrix.checkMatrix(t);for(var e=this.rows,r=this.columns,n=t.rows,i=t.columns,o=new Matrix(e*n,r*i),s=0;s<e;s++)for(var a=0;a<r;a++)for(var h=0;h<n;h++)for(var c=0;c<i;c++)o.set(n*s+h,i*a+c,this.get(s,a)*t.get(h,c));return o}transpose(){for(var t=new Matrix(this.columns,this.rows),e=0;e<this.rows;e++)for(var r=0;r<this.columns;r++)t.set(r,e,this.get(e,r));return t}sortRows(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:compareNumbers;for(var e=0;e<this.rows;e++)this.setRow(e,this.getRow(e).sort(t));return this}sortColumns(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:compareNumbers;for(var e=0;e<this.columns;e++)this.setColumn(e,this.getColumn(e).sort(t));return this}subMatrix(t,e,r,n){checkRange(this,t,e,r,n);for(var i=new Matrix(e-t+1,n-r+1),o=t;o<=e;o++)for(var s=r;s<=n;s++)i.set(o-t,s-r,this.get(o,s));return i}subMatrixRow(t,e,r){if(void 0===e&&(e=0),void 0===r&&(r=this.columns-1),e>r||e<0||e>=this.columns||r<0||r>=this.columns)throw new RangeError("Argument out of range");for(var n=new Matrix(t.length,r-e+1),i=0;i<t.length;i++)for(var o=e;o<=r;o++){if(t[i]<0||t[i]>=this.rows)throw new RangeError("Row index out of range: ".concat(t[i]));n.set(i,o-e,this.get(t[i],o))}return n}subMatrixColumn(t,e,r){if(void 0===e&&(e=0),void 0===r&&(r=this.rows-1),e>r||e<0||e>=this.rows||r<0||r>=this.rows)throw new RangeError("Argument out of range");for(var n=new Matrix(r-e+1,t.length),i=0;i<t.length;i++)for(var o=e;o<=r;o++){if(t[i]<0||t[i]>=this.columns)throw new RangeError("Column index out of range: ".concat(t[i]));n.set(o-e,i,this.get(o,t[i]))}return n}setSubMatrix(t,e,r){checkRange(this,e,e+(t=Matrix.checkMatrix(t)).rows-1,r,r+t.columns-1);for(var n=0;n<t.rows;n++)for(var i=0;i<t.columns;i++)this.set(e+n,r+i,t.get(n,i));return this}selection(t,e){for(var r=checkIndices(this,t,e),n=new Matrix(t.length,e.length),i=0;i<r.row.length;i++)for(var o=r.row[i],s=0;s<r.column.length;s++){var a=r.column[s];n.set(i,s,this.get(o,a))}return n}trace(){for(var t=Math.min(this.rows,this.columns),e=0,r=0;r<t;r++)e+=this.get(r,r);return e}clone(){for(var t=new Matrix(this.rows,this.columns),e=0;e<this.rows;e++)for(var r=0;r<this.columns;r++)t.set(e,r,this.get(e,r));return t}sum(t){switch(t){case"row":return sumByRow(this);case"column":return sumByColumn(this);case void 0:return sumAll(this);default:throw new Error("invalid option: ".concat(t))}}product(t){switch(t){case"row":return productByRow(this);case"column":return productByColumn(this);case void 0:return productAll(this);default:throw new Error("invalid option: ".concat(t))}}mean(t){const e=this.sum(t);switch(t){case"row":for(let t=0;t<this.rows;t++)e[t]/=this.columns;return e;case"column":for(let t=0;t<this.columns;t++)e[t]/=this.rows;return e;case void 0:return e/this.size;default:throw new Error("invalid option: ".concat(t))}}variance(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if("object"==typeof t&&(e=t,t=void 0),"object"!=typeof e)throw new TypeError("options must be an object");const{unbiased:r=!0,mean:n=this.mean(t)}=e;if("boolean"!=typeof r)throw new TypeError("unbiased must be a boolean");switch(t){case"row":if(!Array.isArray(n))throw new TypeError("mean must be an array");return varianceByRow(this,r,n);case"column":if(!Array.isArray(n))throw new TypeError("mean must be an array");return varianceByColumn(this,r,n);case void 0:if("number"!=typeof n)throw new TypeError("mean must be a number");return varianceAll(this,r,n);default:throw new Error("invalid option: ".concat(t))}}standardDeviation(t,e){"object"==typeof t&&(e=t,t=void 0);const r=this.variance(t,e);if(void 0===t)return Math.sqrt(r);for(var n=0;n<r.length;n++)r[n]=Math.sqrt(r[n]);return r}center(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if("object"==typeof t&&(e=t,t=void 0),"object"!=typeof e)throw new TypeError("options must be an object");const{center:r=this.mean(t)}=e;switch(t){case"row":if(!Array.isArray(r))throw new TypeError("center must be an array");return centerByRow(this,r),this;case"column":if(!Array.isArray(r))throw new TypeError("center must be an array");return centerByColumn(this,r),this;case void 0:if("number"!=typeof r)throw new TypeError("center must be a number");return centerAll(this,r),this;default:throw new Error("invalid option: ".concat(t))}}scale(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if("object"==typeof t&&(e=t,t=void 0),"object"!=typeof e)throw new TypeError("options must be an object");let r=e.scale;switch(t){case"row":if(void 0===r)r=getScaleByRow(this);else if(!Array.isArray(r))throw new TypeError("scale must be an array");return scaleByRow(this,r),this;case"column":if(void 0===r)r=getScaleByColumn(this);else if(!Array.isArray(r))throw new TypeError("scale must be an array");return scaleByColumn(this,r),this;case void 0:if(void 0===r)r=getScaleAll(this);else if("number"!=typeof r)throw new TypeError("scale must be a number");return scaleAll(this,r),this;default:throw new Error("invalid option: ".concat(t))}}}function compareNumbers(t,e){return t-e}AbstractMatrix.prototype.klass="Matrix","undefined"!=typeof Symbol&&(AbstractMatrix.prototype[Symbol.for("nodejs.util.inspect.custom")]=inspectMatrix),AbstractMatrix.random=AbstractMatrix.rand,AbstractMatrix.randomInt=AbstractMatrix.randInt,AbstractMatrix.diagonal=AbstractMatrix.diag,AbstractMatrix.prototype.diagonal=AbstractMatrix.prototype.diag,AbstractMatrix.identity=AbstractMatrix.eye,AbstractMatrix.prototype.negate=AbstractMatrix.prototype.neg,AbstractMatrix.prototype.tensorProduct=AbstractMatrix.prototype.kroneckerProduct;class Matrix extends AbstractMatrix{constructor(t,e){if(super(),Matrix.isMatrix(t))return t.clone();if(Number.isInteger(t)&&t>0){if(this.data=[],!(Number.isInteger(e)&&e>0))throw new TypeError("nColumns must be a positive integer");for(let r=0;r<t;r++)this.data.push(new Float64Array(e))}else{if(!Array.isArray(t))throw new TypeError("First argument must be a positive number or an array");{const r=t;if(t=r.length,"number"!=typeof(e=r[0].length)||0===e)throw new TypeError("Data must be a 2D array with at least one element");this.data=[];for(let n=0;n<t;n++){if(r[n].length!==e)throw new RangeError("Inconsistent array dimensions");this.data.push(Float64Array.from(r[n]))}}}return this.rows=t,this.columns=e,this}set(t,e,r){return this.data[t][e]=r,this}get(t,e){return this.data[t][e]}removeRow(t){if(checkRowIndex(this,t),1===this.rows)throw new RangeError("A matrix cannot have less than one row");return this.data.splice(t,1),this.rows-=1,this}addRow(t,e){return void 0===e&&(e=t,t=this.rows),checkRowIndex(this,t,!0),e=Float64Array.from(checkRowVector(this,e)),this.data.splice(t,0,e),this.rows+=1,this}removeColumn(t){if(checkColumnIndex(this,t),1===this.columns)throw new RangeError("A matrix cannot have less than one column");for(var e=0;e<this.rows;e++){const r=new Float64Array(this.columns-1);for(let n=0;n<t;n++)r[n]=this.data[e][n];for(let n=t+1;n<this.columns;n++)r[n-1]=this.data[e][n];this.data[e]=r}return this.columns-=1,this}addColumn(t,e){void 0===e&&(e=t,t=this.columns),checkColumnIndex(this,t,!0),e=checkColumnVector(this,e);for(var r=0;r<this.rows;r++){const n=new Float64Array(this.columns+1);let i=0;for(;i<t;i++)n[i]=this.data[r][i];for(n[i++]=e[r];i<this.columns+1;i++)n[i]=this.data[r][i-1];this.data[r]=n}return this.columns+=1,this}}installMathOperations(AbstractMatrix,Matrix);class BaseView extends AbstractMatrix{constructor(t,e,r){super(),this.matrix=t,this.rows=e,this.columns=r}}class MatrixColumnView extends BaseView{constructor(t,e){checkColumnIndex(t,e),super(t,t.rows,1),this.column=e}set(t,e,r){return this.matrix.set(t,this.column,r),this}get(t){return this.matrix.get(t,this.column)}}class MatrixColumnSelectionView extends BaseView{constructor(t,e){e=checkColumnIndices(t,e),super(t,t.rows,e.length),this.columnIndices=e}set(t,e,r){return this.matrix.set(t,this.columnIndices[e],r),this}get(t,e){return this.matrix.get(t,this.columnIndices[e])}}class MatrixFlipColumnView extends BaseView{constructor(t){super(t,t.rows,t.columns)}set(t,e,r){return this.matrix.set(t,this.columns-e-1,r),this}get(t,e){return this.matrix.get(t,this.columns-e-1)}}class MatrixFlipRowView extends BaseView{constructor(t){super(t,t.rows,t.columns)}set(t,e,r){return this.matrix.set(this.rows-t-1,e,r),this}get(t,e){return this.matrix.get(this.rows-t-1,e)}}class MatrixRowView extends BaseView{constructor(t,e){checkRowIndex(t,e),super(t,1,t.columns),this.row=e}set(t,e,r){return this.matrix.set(this.row,e,r),this}get(t,e){return this.matrix.get(this.row,e)}}class MatrixRowSelectionView extends BaseView{constructor(t,e){super(t,(e=checkRowIndices(t,e)).length,t.columns),this.rowIndices=e}set(t,e,r){return this.matrix.set(this.rowIndices[t],e,r),this}get(t,e){return this.matrix.get(this.rowIndices[t],e)}}class MatrixSelectionView extends BaseView{constructor(t,e,r){var n=checkIndices(t,e,r);super(t,n.row.length,n.column.length),this.rowIndices=n.row,this.columnIndices=n.column}set(t,e,r){return this.matrix.set(this.rowIndices[t],this.columnIndices[e],r),this}get(t,e){return this.matrix.get(this.rowIndices[t],this.columnIndices[e])}}class MatrixSubView extends BaseView{constructor(t,e,r,n,i){checkRange(t,e,r,n,i),super(t,r-e+1,i-n+1),this.startRow=e,this.startColumn=n}set(t,e,r){return this.matrix.set(this.startRow+t,this.startColumn+e,r),this}get(t,e){return this.matrix.get(this.startRow+t,this.startColumn+e)}}class MatrixTransposeView extends BaseView{constructor(t){super(t,t.columns,t.rows)}set(t,e,r){return this.matrix.set(e,t,r),this}get(t,e){return this.matrix.get(e,t)}}class WrapperMatrix1D extends AbstractMatrix{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{rows:r=1}=e;if(t.length%r!=0)throw new Error("the data length is not divisible by the number of rows");super(),this.rows=r,this.columns=t.length/r,this.data=t}set(t,e,r){var n=this._calculateIndex(t,e);return this.data[n]=r,this}get(t,e){var r=this._calculateIndex(t,e);return this.data[r]}_calculateIndex(t,e){return t*this.columns+e}}class WrapperMatrix2D extends AbstractMatrix{constructor(t){super(),this.data=t,this.rows=t.length,this.columns=t[0].length}set(t,e,r){return this.data[t][e]=r,this}get(t,e){return this.data[t][e]}}function wrap(t,e){if(Array.isArray(t))return t[0]&&Array.isArray(t[0])?new WrapperMatrix2D(t):new WrapperMatrix1D(t,e);throw new Error("the argument is not an array")}class LuDecomposition{constructor(t){var e,r,n,i,o,s,a,h,c,u=(t=WrapperMatrix2D.checkMatrix(t)).clone(),l=u.rows,f=u.columns,m=new Float64Array(l),g=1;for(e=0;e<l;e++)m[e]=e;for(h=new Float64Array(l),r=0;r<f;r++){for(e=0;e<l;e++)h[e]=u.get(e,r);for(e=0;e<l;e++){for(c=Math.min(e,r),o=0,n=0;n<c;n++)o+=u.get(e,n)*h[n];h[e]-=o,u.set(e,r,h[e])}for(i=r,e=r+1;e<l;e++)Math.abs(h[e])>Math.abs(h[i])&&(i=e);if(i!==r){for(n=0;n<f;n++)s=u.get(i,n),u.set(i,n,u.get(r,n)),u.set(r,n,s);a=m[i],m[i]=m[r],m[r]=a,g=-g}if(r<l&&0!==u.get(r,r))for(e=r+1;e<l;e++)u.set(e,r,u.get(e,r)/u.get(r,r))}this.LU=u,this.pivotVector=m,this.pivotSign=g}isSingular(){for(var t=this.LU,e=t.columns,r=0;r<e;r++)if(0===t.get(r,r))return!0;return!1}solve(t){t=Matrix.checkMatrix(t);var e=this.LU;if(e.rows!==t.rows)throw new Error("Invalid matrix dimensions");if(this.isSingular())throw new Error("LU matrix is singular");var r,n,i,o=t.columns,s=t.subMatrixRow(this.pivotVector,0,o-1),a=e.columns;for(i=0;i<a;i++)for(r=i+1;r<a;r++)for(n=0;n<o;n++)s.set(r,n,s.get(r,n)-s.get(i,n)*e.get(r,i));for(i=a-1;i>=0;i--){for(n=0;n<o;n++)s.set(i,n,s.get(i,n)/e.get(i,i));for(r=0;r<i;r++)for(n=0;n<o;n++)s.set(r,n,s.get(r,n)-s.get(i,n)*e.get(r,i))}return s}get determinant(){var t=this.LU;if(!t.isSquare())throw new Error("Matrix must be square");for(var e=this.pivotSign,r=t.columns,n=0;n<r;n++)e*=t.get(n,n);return e}get lowerTriangularMatrix(){for(var t=this.LU,e=t.rows,r=t.columns,n=new Matrix(e,r),i=0;i<e;i++)for(var o=0;o<r;o++)i>o?n.set(i,o,t.get(i,o)):i===o?n.set(i,o,1):n.set(i,o,0);return n}get upperTriangularMatrix(){for(var t=this.LU,e=t.rows,r=t.columns,n=new Matrix(e,r),i=0;i<e;i++)for(var o=0;o<r;o++)i<=o?n.set(i,o,t.get(i,o)):n.set(i,o,0);return n}get pivotPermutationVector(){return Array.from(this.pivotVector)}}function hypotenuse(t,e){var r=0;return Math.abs(t)>Math.abs(e)?(r=e/t,Math.abs(t)*Math.sqrt(1+r*r)):0!==e?(r=t/e,Math.abs(e)*Math.sqrt(1+r*r)):0}class QrDecomposition{constructor(t){var e,r,n,i,o=(t=WrapperMatrix2D.checkMatrix(t)).clone(),s=t.rows,a=t.columns,h=new Float64Array(a);for(n=0;n<a;n++){var c=0;for(e=n;e<s;e++)c=hypotenuse(c,o.get(e,n));if(0!==c){for(o.get(n,n)<0&&(c=-c),e=n;e<s;e++)o.set(e,n,o.get(e,n)/c);for(o.set(n,n,o.get(n,n)+1),r=n+1;r<a;r++){for(i=0,e=n;e<s;e++)i+=o.get(e,n)*o.get(e,r);for(i=-i/o.get(n,n),e=n;e<s;e++)o.set(e,r,o.get(e,r)+i*o.get(e,n))}}h[n]=-c}this.QR=o,this.Rdiag=h}solve(t){t=Matrix.checkMatrix(t);var e=this.QR,r=e.rows;if(t.rows!==r)throw new Error("Matrix row dimensions must agree");if(!this.isFullRank())throw new Error("Matrix is rank deficient");var n,i,o,s,a=t.columns,h=t.clone(),c=e.columns;for(o=0;o<c;o++)for(i=0;i<a;i++){for(s=0,n=o;n<r;n++)s+=e.get(n,o)*h.get(n,i);for(s=-s/e.get(o,o),n=o;n<r;n++)h.set(n,i,h.get(n,i)+s*e.get(n,o))}for(o=c-1;o>=0;o--){for(i=0;i<a;i++)h.set(o,i,h.get(o,i)/this.Rdiag[o]);for(n=0;n<o;n++)for(i=0;i<a;i++)h.set(n,i,h.get(n,i)-h.get(o,i)*e.get(n,o))}return h.subMatrix(0,c-1,0,a-1)}isFullRank(){for(var t=this.QR.columns,e=0;e<t;e++)if(0===this.Rdiag[e])return!1;return!0}get upperTriangularMatrix(){var t,e,r=this.QR,n=r.columns,i=new Matrix(n,n);for(t=0;t<n;t++)for(e=0;e<n;e++)t<e?i.set(t,e,r.get(t,e)):t===e?i.set(t,e,this.Rdiag[t]):i.set(t,e,0);return i}get orthogonalMatrix(){var t,e,r,n,i=this.QR,o=i.rows,s=i.columns,a=new Matrix(o,s);for(r=s-1;r>=0;r--){for(t=0;t<o;t++)a.set(t,r,0);for(a.set(r,r,1),e=r;e<s;e++)if(0!==i.get(r,r)){for(n=0,t=r;t<o;t++)n+=i.get(t,r)*a.get(t,e);for(n=-n/i[r][r],t=r;t<o;t++)a.set(t,e,a.get(t,e)+n*i.get(t,r))}}return a}}class SingularValueDecomposition{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};var r=(t=WrapperMatrix2D.checkMatrix(t)).rows,n=t.columns;const{computeLeftSingularVectors:i=!0,computeRightSingularVectors:o=!0,autoTranspose:s=!1}=e;var a,h=Boolean(i),c=Boolean(o),u=!1;if(r<n)if(s){r=(a=t.transpose()).rows,n=a.columns,u=!0;var l=h;h=c,c=l}else a=t.clone(),console.warn("Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose");else a=t.clone();var f=Math.min(r,n),m=Math.min(r+1,n),g=new Float64Array(m),d=new Matrix(r,f),p=new Matrix(n,n),w=new Float64Array(n),v=new Float64Array(r),x=new Float64Array(m);for(let t=0;t<m;t++)x[t]=t;var y=Math.min(r-1,n),M=Math.max(0,Math.min(n-2,r)),b=Math.max(y,M);for(let t=0;t<b;t++){if(t<y){g[t]=0;for(let e=t;e<r;e++)g[t]=hypotenuse(g[t],a.get(e,t));if(0!==g[t]){a.get(t,t)<0&&(g[t]=-g[t]);for(let e=t;e<r;e++)a.set(e,t,a.get(e,t)/g[t]);a.set(t,t,a.get(t,t)+1)}g[t]=-g[t]}for(let e=t+1;e<n;e++){if(t<y&&0!==g[t]){let n=0;for(let i=t;i<r;i++)n+=a.get(i,t)*a.get(i,e);n=-n/a.get(t,t);for(let i=t;i<r;i++)a.set(i,e,a.get(i,e)+n*a.get(i,t))}w[e]=a.get(t,e)}if(h&&t<y)for(let e=t;e<r;e++)d.set(e,t,a.get(e,t));if(t<M){w[t]=0;for(let e=t+1;e<n;e++)w[t]=hypotenuse(w[t],w[e]);if(0!==w[t]){w[t+1]<0&&(w[t]=0-w[t]);for(let e=t+1;e<n;e++)w[e]/=w[t];w[t+1]+=1}if(w[t]=-w[t],t+1<r&&0!==w[t]){for(let e=t+1;e<r;e++)v[e]=0;for(let e=t+1;e<r;e++)for(let r=t+1;r<n;r++)v[e]+=w[r]*a.get(e,r);for(let e=t+1;e<n;e++){let n=-w[e]/w[t+1];for(let i=t+1;i<r;i++)a.set(i,e,a.get(i,e)+n*v[i])}}if(c)for(let e=t+1;e<n;e++)p.set(e,t,w[e])}}let S=Math.min(n,r+1);if(y<n&&(g[y]=a.get(y,y)),r<S&&(g[S-1]=0),M+1<S&&(w[M]=a.get(M,S-1)),w[S-1]=0,h){for(let t=y;t<f;t++){for(let e=0;e<r;e++)d.set(e,t,0);d.set(t,t,1)}for(let t=y-1;t>=0;t--)if(0!==g[t]){for(let e=t+1;e<f;e++){let n=0;for(let i=t;i<r;i++)n+=d.get(i,t)*d.get(i,e);n=-n/d.get(t,t);for(let i=t;i<r;i++)d.set(i,e,d.get(i,e)+n*d.get(i,t))}for(let e=t;e<r;e++)d.set(e,t,-d.get(e,t));d.set(t,t,1+d.get(t,t));for(let e=0;e<t-1;e++)d.set(e,t,0)}else{for(let e=0;e<r;e++)d.set(e,t,0);d.set(t,t,1)}}if(c)for(let t=n-1;t>=0;t--){if(t<M&&0!==w[t])for(let e=t+1;e<n;e++){let r=0;for(let i=t+1;i<n;i++)r+=p.get(i,t)*p.get(i,e);r=-r/p.get(t+1,t);for(let i=t+1;i<n;i++)p.set(i,e,p.get(i,e)+r*p.get(i,t))}for(let e=0;e<n;e++)p.set(e,t,0);p.set(t,t,1)}for(var A=S-1,E=Number.EPSILON;S>0;){let t,e;for(t=S-2;t>=-1&&-1!==t;t--){const e=Number.MIN_VALUE+E*Math.abs(g[t]+Math.abs(g[t+1]));if(Math.abs(w[t])<=e||Number.isNaN(w[t])){w[t]=0;break}}if(t===S-2)e=4;else{let r;for(r=S-1;r>=t&&r!==t;r--){let e=(r!==S?Math.abs(w[r]):0)+(r!==t+1?Math.abs(w[r-1]):0);if(Math.abs(g[r])<=E*e){g[r]=0;break}}r===t?e=3:r===S-1?e=1:(e=2,t=r)}switch(t++,e){case 1:{let e=w[S-2];w[S-2]=0;for(let r=S-2;r>=t;r--){let i=hypotenuse(g[r],e),o=g[r]/i,s=e/i;if(g[r]=i,r!==t&&(e=-s*w[r-1],w[r-1]=o*w[r-1]),c)for(let t=0;t<n;t++)i=o*p.get(t,r)+s*p.get(t,S-1),p.set(t,S-1,-s*p.get(t,r)+o*p.get(t,S-1)),p.set(t,r,i)}break}case 2:{let e=w[t-1];w[t-1]=0;for(let n=t;n<S;n++){let i=hypotenuse(g[n],e),o=g[n]/i,s=e/i;if(g[n]=i,e=-s*w[n],w[n]=o*w[n],h)for(let e=0;e<r;e++)i=o*d.get(e,n)+s*d.get(e,t-1),d.set(e,t-1,-s*d.get(e,n)+o*d.get(e,t-1)),d.set(e,n,i)}break}case 3:{const e=Math.max(Math.abs(g[S-1]),Math.abs(g[S-2]),Math.abs(w[S-2]),Math.abs(g[t]),Math.abs(w[t])),i=g[S-1]/e,o=g[S-2]/e,s=w[S-2]/e,a=g[t]/e,u=w[t]/e,l=((o+i)*(o-i)+s*s)/2,f=i*s*(i*s);let m=0;0===l&&0===f||(m=f/(l+(m=l<0?0-Math.sqrt(l*l+f):Math.sqrt(l*l+f))));let v=(a+i)*(a-i)+m,x=a*u;for(let e=t;e<S-1;e++){let i=hypotenuse(v,x);0===i&&(i=Number.MIN_VALUE);let o=v/i,s=x/i;if(e!==t&&(w[e-1]=i),v=o*g[e]+s*w[e],w[e]=o*w[e]-s*g[e],x=s*g[e+1],g[e+1]=o*g[e+1],c)for(let t=0;t<n;t++)i=o*p.get(t,e)+s*p.get(t,e+1),p.set(t,e+1,-s*p.get(t,e)+o*p.get(t,e+1)),p.set(t,e,i);if(0===(i=hypotenuse(v,x))&&(i=Number.MIN_VALUE),o=v/i,s=x/i,g[e]=i,v=o*w[e]+s*g[e+1],g[e+1]=-s*w[e]+o*g[e+1],x=s*w[e+1],w[e+1]=o*w[e+1],h&&e<r-1)for(let t=0;t<r;t++)i=o*d.get(t,e)+s*d.get(t,e+1),d.set(t,e+1,-s*d.get(t,e)+o*d.get(t,e+1)),d.set(t,e,i)}w[S-2]=v;break}case 4:if(g[t]<=0&&(g[t]=g[t]<0?-g[t]:0,c))for(let e=0;e<=A;e++)p.set(e,t,-p.get(e,t));for(;t<A&&!(g[t]>=g[t+1]);){let e=g[t];if(g[t]=g[t+1],g[t+1]=e,c&&t<n-1)for(let r=0;r<n;r++)e=p.get(r,t+1),p.set(r,t+1,p.get(r,t)),p.set(r,t,e);if(h&&t<r-1)for(let n=0;n<r;n++)e=d.get(n,t+1),d.set(n,t+1,d.get(n,t)),d.set(n,t,e);t++}S--}}if(u){var R=p;p=d,d=R}this.m=r,this.n=n,this.s=g,this.U=d,this.V=p}solve(t){var e=t,r=this.threshold,n=this.s.length,i=Matrix.zeros(n,n);for(let t=0;t<n;t++)Math.abs(this.s[t])<=r?i.set(t,t,0):i.set(t,t,1/this.s[t]);var o=this.U,s=this.rightSingularVectors,a=s.mmul(i),h=s.rows,c=o.rows,u=Matrix.zeros(h,c);for(let t=0;t<h;t++)for(let e=0;e<c;e++){let r=0;for(let i=0;i<n;i++)r+=a.get(t,i)*o.get(e,i);u.set(t,e,r)}return u.mmul(e)}solveForDiagonal(t){return this.solve(Matrix.diag(t))}inverse(){var t=this.V,e=this.threshold,r=t.rows,n=t.columns,i=new Matrix(r,this.s.length);for(let o=0;o<r;o++)for(let r=0;r<n;r++)Math.abs(this.s[r])>e&&i.set(o,r,t.get(o,r)/this.s[r]);var o=this.U,s=o.rows,a=o.columns,h=new Matrix(r,s);for(let t=0;t<r;t++)for(let e=0;e<s;e++){let r=0;for(let n=0;n<a;n++)r+=i.get(t,n)*o.get(e,n);h.set(t,e,r)}return h}get condition(){return this.s[0]/this.s[Math.min(this.m,this.n)-1]}get norm2(){return this.s[0]}get rank(){for(var t=Math.max(this.m,this.n)*this.s[0]*Number.EPSILON,e=0,r=this.s,n=0,i=r.length;n<i;n++)r[n]>t&&e++;return e}get diagonal(){return Array.from(this.s)}get threshold(){return Number.EPSILON/2*Math.max(this.m,this.n)*this.s[0]}get leftSingularVectors(){return this.U}get rightSingularVectors(){return this.V}get diagonalMatrix(){return Matrix.diag(this.s)}}function inverse(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return t=WrapperMatrix2D.checkMatrix(t),e?new SingularValueDecomposition(t).inverse():solve(t,Matrix.eye(t.rows))}function solve(t,e){let r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return t=WrapperMatrix2D.checkMatrix(t),e=WrapperMatrix2D.checkMatrix(e),r?new SingularValueDecomposition(t).solve(e):t.isSquare()?new LuDecomposition(t).solve(e):new QrDecomposition(t).solve(e)}function determinant(t){var e,r,n,i,o,s;if((t=Matrix.checkMatrix(t)).isSquare())return 2===t.columns?(e=t.get(0,0),r=t.get(0,1),n=t.get(1,0),e*t.get(1,1)-r*n):3===t.columns?(i=new MatrixSelectionView(t,[1,2],[1,2]),o=new MatrixSelectionView(t,[1,2],[0,2]),s=new MatrixSelectionView(t,[1,2],[0,1]),e=t.get(0,0),r=t.get(0,1),n=t.get(0,2),e*determinant(i)-r*determinant(o)+n*determinant(s)):new LuDecomposition(t).determinant;throw Error("determinant can only be calculated for a square matrix")}function xrange(t,e){for(var r=[],n=0;n<t;n++)n!==e&&r.push(n);return r}function dependenciesOneRow(t,e,r){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1e-9;if(t>(arguments.length>4&&void 0!==arguments[4]?arguments[4]:1e-9))return new Array(e.rows+1).fill(0);for(var i=e.addRow(r,[0]),o=0;o<i.rows;o++)Math.abs(i.get(o,0))<n&&i.set(o,0,0);return i.to1DArray()}function linearDependencies(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{thresholdValue:r=1e-9,thresholdError:n=1e-9}=e;for(var i=(t=Matrix.checkMatrix(t)).rows,o=new Matrix(i,i),s=0;s<i;s++){var a=Matrix.columnVector(t.getRow(s)),h=t.subMatrixRow(xrange(i,s)).transpose(),c=new SingularValueDecomposition(h).solve(a),u=Matrix.sub(a,h.mmul(c)).abs().max();o.setRow(s,dependenciesOneRow(u,c,s,r,n))}return o}function pseudoInverse(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Number.EPSILON;t=Matrix.checkMatrix(t);for(var r=new SingularValueDecomposition(t,{autoTranspose:!0}),n=r.leftSingularVectors,i=r.rightSingularVectors,o=r.diagonal,s=0;s<o.length;s++)Math.abs(o[s])>e?o[s]=1/o[s]:o[s]=0;return i.mmul(Matrix.diag(o).mmul(n.transpose()))}function covariance(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:t,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};t=Matrix.checkMatrix(t);let n=!1;if("object"!=typeof e||Matrix.isMatrix(e)||Array.isArray(e)?e=Matrix.checkMatrix(e):(r=e,e=t,n=!0),t.rows!==e.rows)throw new TypeError("Both matrices must have the same number of rows");const{center:i=!0}=r;i&&(t=t.center("column"),n||(e=e.center("column")));const o=t.transpose().mmul(e);for(let e=0;e<o.rows;e++)for(let r=0;r<o.columns;r++)o.set(e,r,o.get(e,r)*(1/(t.rows-1)));return o}function correlation(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:t,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};t=Matrix.checkMatrix(t);let n=!1;if("object"!=typeof e||Matrix.isMatrix(e)||Array.isArray(e)?e=Matrix.checkMatrix(e):(r=e,e=t,n=!0),t.rows!==e.rows)throw new TypeError("Both matrices must have the same number of rows");const{center:i=!0,scale:o=!0}=r;i&&(t.center("column"),n||e.center("column")),o&&(t.scale("column"),n||e.scale("column"));const s=t.standardDeviation("column",{unbiased:!0}),a=n?s:e.standardDeviation("column",{unbiased:!0}),h=t.transpose().mmul(e);for(let e=0;e<h.rows;e++)for(let r=0;r<h.columns;r++)h.set(e,r,h.get(e,r)*(1/(s[e]*a[r]))*(1/(t.rows-1)));return h}class EigenvalueDecomposition{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{assumeSymmetric:r=!1}=e;if(!(t=WrapperMatrix2D.checkMatrix(t)).isSquare())throw new Error("Matrix is not a square matrix");var n,i,o=t.columns,s=new Matrix(o,o),a=new Float64Array(o),h=new Float64Array(o),c=t;if(!!r||t.isSymmetric()){for(n=0;n<o;n++)for(i=0;i<o;i++)s.set(n,i,c.get(n,i));tred2(o,h,a,s),tql2(o,h,a,s)}else{var u=new Matrix(o,o),l=new Float64Array(o);for(i=0;i<o;i++)for(n=0;n<o;n++)u.set(n,i,c.get(n,i));orthes(o,u,l,s),hqr2(o,h,a,s,u)}this.n=o,this.e=h,this.d=a,this.V=s}get realEigenvalues(){return Array.from(this.d)}get imaginaryEigenvalues(){return Array.from(this.e)}get eigenvectorMatrix(){return this.V}get diagonalMatrix(){var t,e,r=this.n,n=this.e,i=this.d,o=new Matrix(r,r);for(t=0;t<r;t++){for(e=0;e<r;e++)o.set(t,e,0);o.set(t,t,i[t]),n[t]>0?o.set(t,t+1,n[t]):n[t]<0&&o.set(t,t-1,n[t])}return o}}function tred2(t,e,r,n){var i,o,s,a,h,c,u,l;for(h=0;h<t;h++)r[h]=n.get(t-1,h);for(a=t-1;a>0;a--){for(l=0,s=0,c=0;c<a;c++)l+=Math.abs(r[c]);if(0===l)for(e[a]=r[a-1],h=0;h<a;h++)r[h]=n.get(a-1,h),n.set(a,h,0),n.set(h,a,0);else{for(c=0;c<a;c++)r[c]/=l,s+=r[c]*r[c];for(i=r[a-1],o=Math.sqrt(s),i>0&&(o=-o),e[a]=l*o,s-=i*o,r[a-1]=i-o,h=0;h<a;h++)e[h]=0;for(h=0;h<a;h++){for(i=r[h],n.set(h,a,i),o=e[h]+n.get(h,h)*i,c=h+1;c<=a-1;c++)o+=n.get(c,h)*r[c],e[c]+=n.get(c,h)*i;e[h]=o}for(i=0,h=0;h<a;h++)e[h]/=s,i+=e[h]*r[h];for(u=i/(s+s),h=0;h<a;h++)e[h]-=u*r[h];for(h=0;h<a;h++){for(i=r[h],o=e[h],c=h;c<=a-1;c++)n.set(c,h,n.get(c,h)-(i*e[c]+o*r[c]));r[h]=n.get(a-1,h),n.set(a,h,0)}}r[a]=s}for(a=0;a<t-1;a++){if(n.set(t-1,a,n.get(a,a)),n.set(a,a,1),0!==(s=r[a+1])){for(c=0;c<=a;c++)r[c]=n.get(c,a+1)/s;for(h=0;h<=a;h++){for(o=0,c=0;c<=a;c++)o+=n.get(c,a+1)*n.get(c,h);for(c=0;c<=a;c++)n.set(c,h,n.get(c,h)-o*r[c])}}for(c=0;c<=a;c++)n.set(c,a+1,0)}for(h=0;h<t;h++)r[h]=n.get(t-1,h),n.set(t-1,h,0);n.set(t-1,t-1,1),e[0]=0}function tql2(t,e,r,n){var i,o,s,a,h,c,u,l,f,m,g,d,p,w,v,x;for(s=1;s<t;s++)e[s-1]=e[s];e[t-1]=0;var y=0,M=0,b=Number.EPSILON;for(c=0;c<t;c++){for(M=Math.max(M,Math.abs(r[c])+Math.abs(e[c])),u=c;u<t&&!(Math.abs(e[u])<=b*M);)u++;if(u>c)do{for(i=r[c],f=hypotenuse(l=(r[c+1]-i)/(2*e[c]),1),l<0&&(f=-f),r[c]=e[c]/(l+f),r[c+1]=e[c]*(l+f),m=r[c+1],o=i-r[c],s=c+2;s<t;s++)r[s]-=o;for(y+=o,l=r[u],d=g=1,p=g,w=e[c+1],v=0,x=0,s=u-1;s>=c;s--)for(p=d,d=g,x=v,i=g*e[s],o=g*l,f=hypotenuse(l,e[s]),e[s+1]=v*f,v=e[s]/f,l=(g=l/f)*r[s]-v*i,r[s+1]=o+v*(g*i+v*r[s]),h=0;h<t;h++)o=n.get(h,s+1),n.set(h,s+1,v*n.get(h,s)+g*o),n.set(h,s,g*n.get(h,s)-v*o);l=-v*x*p*w*e[c]/m,e[c]=v*l,r[c]=g*l}while(Math.abs(e[c])>b*M);r[c]=r[c]+y,e[c]=0}for(s=0;s<t-1;s++){for(h=s,l=r[s],a=s+1;a<t;a++)r[a]<l&&(h=a,l=r[a]);if(h!==s)for(r[h]=r[s],r[s]=l,a=0;a<t;a++)l=n.get(a,s),n.set(a,s,n.get(a,h)),n.set(a,h,l)}}function orthes(t,e,r,n){var i,o,s,a,h,c,u,l=t-1;for(c=1;c<=l-1;c++){for(u=0,a=c;a<=l;a++)u+=Math.abs(e.get(a,c-1));if(0!==u){for(s=0,a=l;a>=c;a--)r[a]=e.get(a,c-1)/u,s+=r[a]*r[a];for(o=Math.sqrt(s),r[c]>0&&(o=-o),s-=r[c]*o,r[c]=r[c]-o,h=c;h<t;h++){for(i=0,a=l;a>=c;a--)i+=r[a]*e.get(a,h);for(i/=s,a=c;a<=l;a++)e.set(a,h,e.get(a,h)-i*r[a])}for(a=0;a<=l;a++){for(i=0,h=l;h>=c;h--)i+=r[h]*e.get(a,h);for(i/=s,h=c;h<=l;h++)e.set(a,h,e.get(a,h)-i*r[h])}r[c]=u*r[c],e.set(c,c-1,u*o)}}for(a=0;a<t;a++)for(h=0;h<t;h++)n.set(a,h,a===h?1:0);for(c=l-1;c>=1;c--)if(0!==e.get(c,c-1)){for(a=c+1;a<=l;a++)r[a]=e.get(a,c-1);for(h=c;h<=l;h++){for(o=0,a=c;a<=l;a++)o+=r[a]*n.get(a,h);for(o=o/r[c]/e.get(c,c-1),a=c;a<=l;a++)n.set(a,h,n.get(a,h)+o*r[a])}}}function hqr2(t,e,r,n,i){var o,s,a,h,c,u,l,f,m,g,d,p,w,v,x,y=t-1,M=t-1,b=Number.EPSILON,S=0,A=0,E=0,R=0,T=0,k=0,N=0,C=0;for(o=0;o<t;o++)for((o<0||o>M)&&(r[o]=i.get(o,o),e[o]=0),s=Math.max(o-1,0);s<t;s++)A+=Math.abs(i.get(o,s));for(;y>=0;){for(h=y;h>0&&(0===(k=Math.abs(i.get(h-1,h-1))+Math.abs(i.get(h,h)))&&(k=A),!(Math.abs(i.get(h,h-1))<b*k));)h--;if(h===y)i.set(y,y,i.get(y,y)+S),r[y]=i.get(y,y),e[y]=0,y--,C=0;else if(h===y-1){if(l=i.get(y,y-1)*i.get(y-1,y),R=(E=(i.get(y-1,y-1)-i.get(y,y))/2)*E+l,N=Math.sqrt(Math.abs(R)),i.set(y,y,i.get(y,y)+S),i.set(y-1,y-1,i.get(y-1,y-1)+S),f=i.get(y,y),R>=0){for(N=E>=0?E+N:E-N,r[y-1]=f+N,r[y]=r[y-1],0!==N&&(r[y]=f-l/N),e[y-1]=0,e[y]=0,E=(f=i.get(y,y-1))/(k=Math.abs(f)+Math.abs(N)),R=N/k,E/=T=Math.sqrt(E*E+R*R),R/=T,s=y-1;s<t;s++)N=i.get(y-1,s),i.set(y-1,s,R*N+E*i.get(y,s)),i.set(y,s,R*i.get(y,s)-E*N);for(o=0;o<=y;o++)N=i.get(o,y-1),i.set(o,y-1,R*N+E*i.get(o,y)),i.set(o,y,R*i.get(o,y)-E*N);for(o=0;o<=M;o++)N=n.get(o,y-1),n.set(o,y-1,R*N+E*n.get(o,y)),n.set(o,y,R*n.get(o,y)-E*N)}else r[y-1]=f+E,r[y]=f+E,e[y-1]=N,e[y]=-N;y-=2,C=0}else{if(f=i.get(y,y),m=0,l=0,h<y&&(m=i.get(y-1,y-1),l=i.get(y,y-1)*i.get(y-1,y)),10===C){for(S+=f,o=0;o<=y;o++)i.set(o,o,i.get(o,o)-f);f=m=.75*(k=Math.abs(i.get(y,y-1))+Math.abs(i.get(y-1,y-2))),l=-.4375*k*k}if(30===C&&(k=(k=(m-f)/2)*k+l)>0){for(k=Math.sqrt(k),m<f&&(k=-k),k=f-l/((m-f)/2+k),o=0;o<=y;o++)i.set(o,o,i.get(o,o)-k);S+=k,f=m=l=.964}for(C+=1,c=y-2;c>=h&&(E=((T=f-(N=i.get(c,c)))*(k=m-N)-l)/i.get(c+1,c)+i.get(c,c+1),R=i.get(c+1,c+1)-N-T-k,T=i.get(c+2,c+1),E/=k=Math.abs(E)+Math.abs(R)+Math.abs(T),R/=k,T/=k,c!==h)&&!(Math.abs(i.get(c,c-1))*(Math.abs(R)+Math.abs(T))<b*(Math.abs(E)*(Math.abs(i.get(c-1,c-1))+Math.abs(N)+Math.abs(i.get(c+1,c+1)))));)c--;for(o=c+2;o<=y;o++)i.set(o,o-2,0),o>c+2&&i.set(o,o-3,0);for(a=c;a<=y-1&&(v=a!==y-1,a!==c&&(E=i.get(a,a-1),R=i.get(a+1,a-1),T=v?i.get(a+2,a-1):0,0!==(f=Math.abs(E)+Math.abs(R)+Math.abs(T))&&(E/=f,R/=f,T/=f)),0!==f);a++)if(k=Math.sqrt(E*E+R*R+T*T),E<0&&(k=-k),0!==k){for(a!==c?i.set(a,a-1,-k*f):h!==c&&i.set(a,a-1,-i.get(a,a-1)),f=(E+=k)/k,m=R/k,N=T/k,R/=E,T/=E,s=a;s<t;s++)E=i.get(a,s)+R*i.get(a+1,s),v&&(E+=T*i.get(a+2,s),i.set(a+2,s,i.get(a+2,s)-E*N)),i.set(a,s,i.get(a,s)-E*f),i.set(a+1,s,i.get(a+1,s)-E*m);for(o=0;o<=Math.min(y,a+3);o++)E=f*i.get(o,a)+m*i.get(o,a+1),v&&(E+=N*i.get(o,a+2),i.set(o,a+2,i.get(o,a+2)-E*T)),i.set(o,a,i.get(o,a)-E),i.set(o,a+1,i.get(o,a+1)-E*R);for(o=0;o<=M;o++)E=f*n.get(o,a)+m*n.get(o,a+1),v&&(E+=N*n.get(o,a+2),n.set(o,a+2,n.get(o,a+2)-E*T)),n.set(o,a,n.get(o,a)-E),n.set(o,a+1,n.get(o,a+1)-E*R)}}}if(0!==A){for(y=t-1;y>=0;y--)if(E=r[y],0===(R=e[y]))for(h=y,i.set(y,y,1),o=y-1;o>=0;o--){for(l=i.get(o,o)-E,T=0,s=h;s<=y;s++)T+=i.get(o,s)*i.get(s,y);if(e[o]<0)N=l,k=T;else if(h=o,0===e[o]?i.set(o,y,0!==l?-T/l:-T/(b*A)):(f=i.get(o,o+1),m=i.get(o+1,o),u=(f*k-N*T)/(R=(r[o]-E)*(r[o]-E)+e[o]*e[o]),i.set(o,y,u),i.set(o+1,y,Math.abs(f)>Math.abs(N)?(-T-l*u)/f:(-k-m*u)/N)),b*(u=Math.abs(i.get(o,y)))*u>1)for(s=o;s<=y;s++)i.set(s,y,i.get(s,y)/u)}else if(R<0)for(h=y-1,Math.abs(i.get(y,y-1))>Math.abs(i.get(y-1,y))?(i.set(y-1,y-1,R/i.get(y,y-1)),i.set(y-1,y,-(i.get(y,y)-E)/i.get(y,y-1))):(x=cdiv(0,-i.get(y-1,y),i.get(y-1,y-1)-E,R),i.set(y-1,y-1,x[0]),i.set(y-1,y,x[1])),i.set(y,y-1,0),i.set(y,y,1),o=y-2;o>=0;o--){for(g=0,d=0,s=h;s<=y;s++)g+=i.get(o,s)*i.get(s,y-1),d+=i.get(o,s)*i.get(s,y);if(l=i.get(o,o)-E,e[o]<0)N=l,T=g,k=d;else if(h=o,0===e[o]?(x=cdiv(-g,-d,l,R),i.set(o,y-1,x[0]),i.set(o,y,x[1])):(f=i.get(o,o+1),m=i.get(o+1,o),p=(r[o]-E)*(r[o]-E)+e[o]*e[o]-R*R,w=2*(r[o]-E)*R,0===p&&0===w&&(p=b*A*(Math.abs(l)+Math.abs(R)+Math.abs(f)+Math.abs(m)+Math.abs(N))),x=cdiv(f*T-N*g+R*d,f*k-N*d-R*g,p,w),i.set(o,y-1,x[0]),i.set(o,y,x[1]),Math.abs(f)>Math.abs(N)+Math.abs(R)?(i.set(o+1,y-1,(-g-l*i.get(o,y-1)+R*i.get(o,y))/f),i.set(o+1,y,(-d-l*i.get(o,y)-R*i.get(o,y-1))/f)):(x=cdiv(-T-m*i.get(o,y-1),-k-m*i.get(o,y),N,R),i.set(o+1,y-1,x[0]),i.set(o+1,y,x[1]))),b*(u=Math.max(Math.abs(i.get(o,y-1)),Math.abs(i.get(o,y))))*u>1)for(s=o;s<=y;s++)i.set(s,y-1,i.get(s,y-1)/u),i.set(s,y,i.get(s,y)/u)}for(o=0;o<t;o++)if(o<0||o>M)for(s=o;s<t;s++)n.set(o,s,i.get(o,s));for(s=t-1;s>=0;s--)for(o=0;o<=M;o++){for(N=0,a=0;a<=Math.min(s,M);a++)N+=n.get(o,a)*i.get(a,s);n.set(o,s,N)}}}function cdiv(t,e,r,n){var i,o;return Math.abs(r)>Math.abs(n)?[(t+(i=n/r)*e)/(o=r+i*n),(e-i*t)/o]:[((i=r/n)*t+e)/(o=n+i*r),(i*e-t)/o]}class CholeskyDecomposition{constructor(t){if(!(t=WrapperMatrix2D.checkMatrix(t)).isSymmetric())throw new Error("Matrix is not symmetric");var e,r,n,i=t,o=i.rows,s=new Matrix(o,o),a=!0;for(r=0;r<o;r++){var h=0;for(n=0;n<r;n++){var c=0;for(e=0;e<n;e++)c+=s.get(n,e)*s.get(r,e);c=(i.get(r,n)-c)/s.get(n,n),s.set(r,n,c),h+=c*c}for(a&=(h=i.get(r,r)-h)>0,s.set(r,r,Math.sqrt(Math.max(h,0))),n=r+1;n<o;n++)s.set(r,n,0)}if(!a)throw new Error("Matrix is not positive definite");this.L=s}solve(t){t=WrapperMatrix2D.checkMatrix(t);var e=this.L,r=e.rows;if(t.rows!==r)throw new Error("Matrix dimensions do not match");var n,i,o,s=t.columns,a=t.clone();for(o=0;o<r;o++)for(i=0;i<s;i++){for(n=0;n<o;n++)a.set(o,i,a.get(o,i)-a.get(n,i)*e.get(o,n));a.set(o,i,a.get(o,i)/e.get(o,o))}for(o=r-1;o>=0;o--)for(i=0;i<s;i++){for(n=o+1;n<r;n++)a.set(o,i,a.get(o,i)-a.get(n,i)*e.get(n,o));a.set(o,i,a.get(o,i)/e.get(o,o))}return a}get lowerTriangularMatrix(){return this.L}}var MatrixLib=Object.freeze({AbstractMatrix:AbstractMatrix,default:Matrix,Matrix:Matrix,wrap:wrap,WrapperMatrix1D:WrapperMatrix1D,WrapperMatrix2D:WrapperMatrix2D,solve:solve,inverse:inverse,determinant:determinant,linearDependencies:linearDependencies,pseudoInverse:pseudoInverse,covariance:covariance,correlation:correlation,SingularValueDecomposition:SingularValueDecomposition,SVD:SingularValueDecomposition,EigenvalueDecomposition:EigenvalueDecomposition,EVD:EigenvalueDecomposition,CholeskyDecomposition:CholeskyDecomposition,CHO:CholeskyDecomposition,LuDecomposition:LuDecomposition,LU:LuDecomposition,QrDecomposition:QrDecomposition,QR:QrDecomposition,MatrixColumnView:MatrixColumnView,MatrixColumnSelectionView:MatrixColumnSelectionView,MatrixFlipColumnView:MatrixFlipColumnView,MatrixFlipRowView:MatrixFlipRowView,MatrixRowView:MatrixRowView,MatrixRowSelectionView:MatrixRowSelectionView,MatrixSelectionView:MatrixSelectionView,MatrixSubView:MatrixSubView,MatrixTransposeView:MatrixTransposeView});function mean(t){if(!src(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");for(var e=0,r=0;r<t.length;r++)e+=t[r];return e/t.length}function toDiscreteDistribution(t,e){for(var r=new Array(e).fill(0),n=0;n<t.length;++n)r[t[n]]+=1/t.length;return Matrix.rowVector(r)}function giniImpurity(t){if(0===t.length)return 0;for(var e=toDiscreteDistribution(t,getNumberOfClasses(t)).getRow(0),r=0,n=0;n<e.length;++n)r+=e[n]*e[n];return 1-r}function getNumberOfClasses(t){return t.filter(function(t,e,r){return r.indexOf(t)===e}).length}function giniGain(t,e){for(var r=0,n=["greater","lesser"],i=0;i<n.length;++i){var o=e[n[i]];r+=giniImpurity(o)*o.length/t.length}return giniImpurity(t)-r}function squaredError(t){for(var e=t.length,r=mean(t),n=0,i=0;i<e;++i){var o=t[i];n+=(o-r)*(o-r)}return n}function regressionError(t,e){for(var r=0,n=["greater","lesser"],i=0;i<n.length;++i){r+=squaredError(e[n[i]])}return r}function matrixSplitter(t,e,r,n){for(var i=[],o=[],s=[],a=[],h=0;h<t.rows;++h)t.get(h,r)<n?(i.push(t.getRow(h)),s.push(e[h])):(o.push(t.getRow(h)),a.push(e[h]));return{greaterX:o,greaterY:a,lesserX:i,lesserY:s}}function mean$1(t,e){return(t+e)/2}function zip(t,e){if(t.length!==e.length)throw new TypeError("Error on zip: the size of a: ".concat(t.length," is different from b: ").concat(e.length));for(var r=new Array(t.length),n=0;n<t.length;++n)r[n]=[t[n],e[n]];return r}const gainFunctions={gini:giniGain,regression:regressionError},splitFunctions={mean:mean$1};class TreeNode{constructor(t){this.kind=t.kind,this.gainFunction=t.gainFunction,this.splitFunction=t.splitFunction,this.minNumSamples=t.minNumSamples,this.maxDepth=t.maxDepth}bestSplit(t,e){for(var r,n,i="classifier"===this.kind?-1/0:1/0,o="classifier"===this.kind?(t,e)=>t>e:(t,e)=>t<e,s=0;s<t.rows;++s)for(var a=t.getRow(s),h=this.featureSplit(a,e),c=0;c<h.length;++c){var u=h[c],l=this.split(a,e,u),f=gainFunctions[this.gainFunction](e,l);o(f,i)&&(r=s,n=u,i=f)}return{maxGain:i,maxColumn:r,maxValue:n}}split(t,e,r){for(var n=[],i=[],o=0;o<t.length;++o)t[o]<r?n.push(e[o]):i.push(e[o]);return{greater:i,lesser:n}}featureSplit(t,e){var r=[],n=zip(t,e);n.sort(function(t,e){return t[0]-e[0]});for(var i=1;i<n.length;++i)n[i-1][1]!==n[i][1]&&r.push(splitFunctions[this.splitFunction](n[i-1][0],n[i][0]));return r}calculatePrediction(t){if("classifier"===this.kind){if(this.distribution=toDiscreteDistribution(t,getNumberOfClasses(t)),0===this.distribution.columns)throw new TypeError("Error on calculate the prediction")}else this.distribution=mean(t)}train(t,e,r,n){if(t.rows<=this.minNumSamples)this.calculatePrediction(e);else{void 0===n&&(n=0);var i=t.transpose(),o=this.bestSplit(i,e);this.splitValue=o.maxValue,this.splitColumn=o.maxColumn,this.gain=o.maxGain;var s=matrixSplitter(t,e,this.splitColumn,this.splitValue);if(r<this.maxDepth&&this.gain>.01&&this.gain!==n&&s.lesserX.length>0&&s.greaterX.length>0){this.left=new TreeNode(this),this.right=new TreeNode(this);var a=new Matrix(s.lesserX),h=new Matrix(s.greaterX);this.left.train(a,s.lesserY,r+1,this.gain),this.right.train(h,s.greaterY,r+1,this.gain)}else this.calculatePrediction(e)}}classify(t){return this.right&&this.left?t[this.splitColumn]<this.splitValue?this.left.classify(t):this.right.classify(t):this.distribution}setNodeParameters(t){void 0!==t.distribution?this.distribution=t.distribution.constructor===Array?new Matrix(t.distribution):t.distribution:(this.distribution=void 0,this.splitValue=t.splitValue,this.splitColumn=t.splitColumn,this.gain=t.gain,this.left=new TreeNode(this),this.right=new TreeNode(this),t.left!=={}&&this.left.setNodeParameters(t.left),t.right!=={}&&this.right.setNodeParameters(t.right))}}const defaultOptions={gainFunction:"gini",splitFunction:"mean",minNumSamples:3,maxDepth:1/0};class DecisionTreeClassifier{constructor(t,e){!0===t?(this.options=e.options,this.root=new TreeNode(e.options),this.root.setNodeParameters(e.root)):(this.options=Object.assign({},defaultOptions,t),this.options.kind="classifier")}train(t,e){this.root=new TreeNode(this.options),t=Matrix.checkMatrix(t),this.root.train(t,e,0,null)}predict(t){t=Matrix.checkMatrix(t);for(var e=new Array(t.rows),r=0;r<t.rows;++r)e[r]=this.root.classify(t.getRow(r)).maxRowIndex(0)[1];return e}toJSON(){return{options:this.options,root:this.root,name:"DTClassifier"}}static load(t){if("DTClassifier"!==t.name)throw new RangeError("Invalid model: ".concat(t.name));return new DecisionTreeClassifier(!0,t)}}const defaultOptions$1={gainFunction:"regression",splitFunction:"mean",minNumSamples:3,maxDepth:1/0};class DecisionTreeRegression{constructor(t,e){!0===t?(this.options=e.options,this.root=new TreeNode(e.options),this.root.setNodeParameters(e.root)):(this.options=Object.assign({},defaultOptions$1,t),this.options.kind="regression")}train(t,e){this.root=new TreeNode(this.options),t=void 0!==t[0]&&void 0===t[0].length?Matrix.columnVector(t):Matrix.checkMatrix(t),this.root.train(t,e,0)}predict(t){void 0!==t[0]&&void 0===t[0].length&&(t=Matrix.columnVector(t)),t=Matrix.checkMatrix(t);for(var e=new Array(t.rows),r=0;r<t.rows;++r)e[r]=this.root.classify(t.getRow(r));return e}toJSON(){return{options:this.options,root:this.root,name:"DTRegression"}}static load(t){if("DTRegression"!==t.name)throw new RangeError("Invalid model:".concat(t.name));return new DecisionTreeRegression(!0,t)}}const SMALLEST_UNSAFE_INTEGER=9007199254740992,LARGEST_SAFE_INTEGER=SMALLEST_UNSAFE_INTEGER-1,UINT32_MAX=-1>>>0,UINT32_SIZE=UINT32_MAX+1,INT32_SIZE=UINT32_SIZE/2,INT32_MAX=INT32_SIZE-1,UINT21_SIZE=1<<21,UINT21_MAX=UINT21_SIZE-1;function int32(t){return 0|t.next()}function add(t,e){return 0===e?t:r=>t(r)+e}function int53(t){const e=0|t.next(),r=t.next()>>>0;return(e&UINT21_MAX)*UINT32_SIZE+r+(e&UINT21_SIZE?-SMALLEST_UNSAFE_INTEGER:0)}function int53Full(t){for(;;){const e=0|t.next();if(!(4194304&e)){const r=t.next()>>>0;return(e&UINT21_MAX)*UINT32_SIZE+r+(e&UINT21_SIZE?-SMALLEST_UNSAFE_INTEGER:0)}if(4194304==(8388607&e)&&0==(0|t.next()))return SMALLEST_UNSAFE_INTEGER}}function uint32(t){return t.next()>>>0}function uint53(t){const e=t.next()&UINT21_MAX,r=t.next()>>>0;return e*UINT32_SIZE+r}function uint53Full(t){for(;;){const e=0|t.next();if(!(e&UINT21_SIZE)){const r=t.next()>>>0;return(e&UINT21_MAX)*UINT32_SIZE+r}if(0==(e&UINT21_MAX)&&0==(0|t.next()))return SMALLEST_UNSAFE_INTEGER}}function isPowerOfTwoMinusOne(t){return 0==(t+1&t)}function bitmask(t){return e=>e.next()&t}function downscaleToLoopCheckedRange(t){const e=t+1,r=e*Math.floor(UINT32_SIZE/e);return t=>{let n=0;do{n=t.next()>>>0}while(n>=r);return n%e}}function downscaleToRange(t){return isPowerOfTwoMinusOne(t)?bitmask(t):downscaleToLoopCheckedRange(t)}function isEvenlyDivisibleByMaxInt32(t){return 0==(0|t)}function upscaleWithHighMasking(t){return e=>{const r=e.next()&t,n=e.next()>>>0;return r*UINT32_SIZE+n}}function upscaleToLoopCheckedRange(t){const e=t*Math.floor(SMALLEST_UNSAFE_INTEGER/t);return r=>{let n=0;do{const t=r.next()&UINT21_MAX,e=r.next()>>>0;n=t*UINT32_SIZE+e}while(n>=e);return n%t}}function upscaleWithinU53(t){const e=t+1;if(isEvenlyDivisibleByMaxInt32(e)){const t=(e/UINT32_SIZE|0)-1;if(isPowerOfTwoMinusOne(t))return upscaleWithHighMasking(t)}return upscaleToLoopCheckedRange(e)}function upscaleWithinI53AndLoopCheck(t,e){return r=>{let n=0;do{const t=0|r.next(),e=r.next()>>>0;n=(t&UINT21_MAX)*UINT32_SIZE+e+(t&UINT21_SIZE?-SMALLEST_UNSAFE_INTEGER:0)}while(n<t||n>e);return n}}function integer(t,e){if(t=Math.floor(t),e=Math.floor(e),t<-SMALLEST_UNSAFE_INTEGER||!isFinite(t))throw new RangeError("Expected min to be at least ".concat(-SMALLEST_UNSAFE_INTEGER));if(e>SMALLEST_UNSAFE_INTEGER||!isFinite(e))throw new RangeError("Expected max to be at most ".concat(SMALLEST_UNSAFE_INTEGER));const r=e-t;return r<=0||!isFinite(r)?()=>t:r===UINT32_MAX?0===t?uint32:add(int32,t+INT32_SIZE):r<UINT32_MAX?add(downscaleToRange(r),t):r===LARGEST_SAFE_INTEGER?add(uint53,t):r<LARGEST_SAFE_INTEGER?add(upscaleWithinU53(r),t):e-1-t===LARGEST_SAFE_INTEGER?add(uint53Full,t):t===-SMALLEST_UNSAFE_INTEGER&&e===SMALLEST_UNSAFE_INTEGER?int53Full:t===-SMALLEST_UNSAFE_INTEGER&&e===LARGEST_SAFE_INTEGER?int53:t===-LARGEST_SAFE_INTEGER&&e===SMALLEST_UNSAFE_INTEGER?add(int53,1):e===SMALLEST_UNSAFE_INTEGER?add(upscaleWithinI53AndLoopCheck(t-1,e-1),1):upscaleWithinI53AndLoopCheck(t,e)}const DEFAULT_STRING_POOL="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_-";function string(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:DEFAULT_STRING_POOL;const e=t.length;if(!e)throw new Error("Expected pool not to be an empty string");const r=integer(0,e-1);return(e,n)=>{let i="";for(let o=0;o<n;++o){const n=r(e);i+=t.charAt(n)}return i}}const LOWER_HEX_POOL="0123456789abcdef",lowerHex=string(LOWER_HEX_POOL),upperHex=string(LOWER_HEX_POOL.toUpperCase()),stringRepeat=(()=>{try{if("xxx"==="x".repeat(3))return(t,e)=>t.repeat(e)}catch(t){}return(t,e)=>{let r="";for(;e>0;)1&e&&(r+=t),e>>=1,t+=t;return r}})(),nativeMath={next:()=>Math.random()*UINT32_SIZE|0},I32Array=(()=>{try{const t=new ArrayBuffer(4),e=new Int32Array(t);if(e[0]=INT32_SIZE,e[0]===-INT32_SIZE)return Int32Array}catch(t){}return Array})();function createEntropy(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:nativeMath,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:16;const r=[];r.push(0|(new Date).getTime());for(let n=1;n<e;++n)r[n]=0|t.next();return r}const imul=(()=>{try{if(-5===Math.imul(UINT32_MAX,5))return Math.imul}catch(t){}return(t,e)=>{const r=65535&t,n=65535&e;return r*n+((t>>>16&65535)*n+r*(e>>>16&65535)<<16>>>0)|0}})(),ARRAY_SIZE=624,ARRAY_MAX=ARRAY_SIZE-1,M=397,ARRAY_SIZE_MINUS_M=ARRAY_SIZE-M,A=2567483615;class MersenneTwister19937{constructor(){this.data=new I32Array(ARRAY_SIZE),this.index=0,this.uses=0}static seed(t){return(new MersenneTwister19937).seed(t)}static seedWithArray(t){return(new MersenneTwister19937).seedWithArray(t)}static autoSeed(){return MersenneTwister19937.seedWithArray(createEntropy())}next(){(0|this.index)>=ARRAY_SIZE&&(refreshData(this.data),this.index=0);const t=this.data[this.index];return this.index=this.index+1|0,this.uses+=1,0|temper(t)}getUseCount(){return this.uses}discard(t){if(t<=0)return this;for(this.uses+=t,(0|this.index)>=ARRAY_SIZE&&(refreshData(this.data),this.index=0);t+this.index>ARRAY_SIZE;)t-=ARRAY_SIZE-this.index,refreshData(this.data),this.index=0;return this.index=this.index+t|0,this}seed(t){let e=0;this.data[0]=e=0|t;for(let t=1;t<ARRAY_SIZE;t=t+1|0)this.data[t]=e=imul(e^e>>>30,1812433253)+t|0;return this.index=ARRAY_SIZE,this.uses=0,this}seedWithArray(t){return this.seed(19650218),seedWithArray(this.data,t),this}}function refreshData(t){let e=0,r=0;for(;(0|e)<ARRAY_SIZE_MINUS_M;e=e+1|0)r=t[e]&INT32_SIZE|t[e+1|0]&INT32_MAX,t[e]=t[e+M|0]^r>>>1^(1&r?A:0);for(;(0|e)<ARRAY_MAX;e=e+1|0)r=t[e]&INT32_SIZE|t[e+1|0]&INT32_MAX,t[e]=t[e-ARRAY_SIZE_MINUS_M|0]^r>>>1^(1&r?A:0);r=t[ARRAY_MAX]&INT32_SIZE|t[0]&INT32_MAX,t[ARRAY_MAX]=t[M-1]^r>>>1^(1&r?A:0)}function temper(t){return t^=t>>>11,t^=t<<7&2636928640,(t^=t<<15&4022730752)^t>>>18}function seedWithArray(t,e){let r=1,n=0;const i=e.length;let o=0|Math.max(i,ARRAY_SIZE),s=0|t[0];for(;(0|o)>0;--o)t[r]=s=(t[r]^imul(s^s>>>30,1664525))+(0|e[n])+(0|n)|0,++n,(0|(r=r+1|0))>ARRAY_MAX&&(t[0]=t[ARRAY_MAX],r=1),n>=i&&(n=0);for(o=ARRAY_MAX;(0|o)>0;--o)t[r]=s=(t[r]^imul(s^s>>>30,1566083941))-r|0,(0|(r=r+1|0))>ARRAY_MAX&&(t[0]=t[ARRAY_MAX],r=1);t[0]=INT32_SIZE}function checkFloat(t){return t>0&&t<=1}function examplesBaggingWithReplacement(t,e,r){var n,i=integer(0,t.rows-1);if(void 0===r)n=MersenneTwister19937.autoSeed();else{if(!Number.isInteger(r))throw new RangeError("Expected seed must be undefined or integer not ".concat(r));n=MersenneTwister19937.seed(r)}for(var o=new Array(t.rows),s=new Array(t.rows),a=0;a<t.rows;++a){var h=i(n);o[a]=t.getRow(h),s[a]=e[h]}return{X:new Matrix(o),y:s}}function featureBagging(t,e,r,n){if(t.columns<e)throw new RangeError("N should be less or equal to the number of columns of X");var i,o=integer(0,t.columns-1);if(void 0===n)i=MersenneTwister19937.autoSeed();else{if(!Number.isInteger(n))throw new RangeError("Expected seed must be undefined or integer not ".concat(n));i=MersenneTwister19937.seed(n)}var s=new Matrix(t.rows,e);if(r)for(var a=new Array(e),h=0;h<e;++h){var c=o(i);a[h]=c,s.setColumn(h,t.getColumn(c))}else{for(a=new Set,c=o(i),h=0;h<e;++h){for(;a.has(c);)c=o(i);s.setColumn(h,t.getColumn(c)),a.add(c)}a=Array.from(a)}return{X:s,usedIndex:a}}class RandomForestBase{constructor(t,e){if(!0===t){this.replacement=e.replacement,this.maxFeatures=e.maxFeatures,this.nEstimators=e.nEstimators,this.treeOptions=e.treeOptions,this.isClassifier=e.isClassifier,this.seed=e.seed,this.n=e.n,this.indexes=e.indexes,this.useSampleBagging=e.useSampleBagging;var r=this.isClassifier?DecisionTreeClassifier:DecisionTreeRegression;this.estimators=e.estimators.map(t=>r.load(t))}else this.replacement=t.replacement,this.maxFeatures=t.maxFeatures,this.nEstimators=t.nEstimators,this.treeOptions=t.treeOptions,this.isClassifier=t.isClassifier,this.seed=t.seed,this.useSampleBagging=t.useSampleBagging}train(t,e){if(t=Matrix.checkMatrix(t),this.maxFeatures=this.maxFeatures||t.columns,checkFloat(this.maxFeatures))this.n=Math.floor(t.columns*this.maxFeatures);else{if(!Number.isInteger(this.maxFeatures))throw new RangeError("Cannot process the maxFeatures parameter ".concat(this.maxFeatures));if(this.maxFeatures>t.columns)throw new RangeError("The maxFeatures parameter should be less than ".concat(t.columns));this.n=this.maxFeatures}if(this.isClassifier)var r=DecisionTreeClassifier;else r=DecisionTreeRegression;this.estimators=new Array(this.nEstimators),this.indexes=new Array(this.nEstimators);for(var n=0;n<this.nEstimators;++n){var i=this.useSampleBagging?examplesBaggingWithReplacement(t,e,this.seed):{X:t,y:e},o=i.X,s=i.y;o=(i=featureBagging(o,this.n,this.replacement,this.seed)).X,this.indexes[n]=i.usedIndex,this.estimators[n]=new r(this.treeOptions),this.estimators[n].train(o,s)}}selection(t){throw new Error("Abstract method 'selection' not implemented!")}predict(t){var e=new Array(this.nEstimators);t=Matrix.checkMatrix(t);for(var r=0;r<this.nEstimators;++r){var n=new MatrixColumnSelectionView(t,this.indexes[r]);e[r]=this.estimators[r].predict(n)}e=new MatrixTransposeView(new WrapperMatrix2D(e));var i=new Array(e.rows);for(r=0;r<e.rows;++r)i[r]=this.selection(e.getRow(r));return i}toJSON(){return{indexes:this.indexes,n:this.n,replacement:this.replacement,maxFeatures:this.maxFeatures,nEstimators:this.nEstimators,treeOptions:this.treeOptions,isClassifier:this.isClassifier,seed:this.seed,estimators:this.estimators.map(t=>t.toJSON()),useSampleBagging:this.useSampleBagging}}}const defaultOptions$2={maxFeatures:1,replacement:!0,nEstimators:10,seed:42,useSampleBagging:!1};class RandomForestClassifier extends RandomForestBase{constructor(t,e){!0===t?super(!0,e.baseModel):((t=Object.assign({},defaultOptions$2,t)).isClassifier=!0,super(t))}selection(t){return mode(t)}toJSON(){return{baseModel:super.toJSON(),name:"RFClassifier"}}static load(t){if("RFClassifier"!==t.name)throw new RangeError("Invalid model: ".concat(t.name));return new RandomForestClassifier(!0,t)}}function mode(t){return t.sort((e,r)=>t.filter(t=>t===e).length-t.filter(t=>t===r).length).pop()}var commonjsGlobal="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function createCommonjsModule(t,e){return t(e={exports:{}},e.exports),e.exports}var medianQuickselect_min=createCommonjsModule(function(t){!function(){function e(t){for(var e=0,i=t.length-1,o=void 0,s=void 0,a=void 0,h=n(e,i);;){if(i<=e)return t[h];if(i==e+1)return t[e]>t[i]&&r(t,e,i),t[h];for(t[o=n(e,i)]>t[i]&&r(t,o,i),t[e]>t[i]&&r(t,e,i),t[o]>t[e]&&r(t,o,e),r(t,o,e+1),s=e+1,a=i;;){do{s++}while(t[e]>t[s]);do{a--}while(t[a]>t[e]);if(a<s)break;r(t,s,a)}r(t,e,a),a<=h&&(e=s),a>=h&&(i=a-1)}}var r=function(t,e,r){var n;return n=[t[r],t[e]],t[e]=n[0],t[r]=n[1],n},n=function(t,e){return~~((t+e)/2)};t.exports?t.exports=e:window.median=e}()});function median(t){if(!src(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");return medianQuickselect_min(t.slice())}const selectionMethods={mean:mean,median:median},defaultOptions$3={maxFeatures:1,replacement:!1,nEstimators:10,treeOptions:{},selectionMethod:"mean",seed:42,useSampleBagging:!1};class RandomForestRegression extends RandomForestBase{constructor(t,e){if(!0===t)super(!0,e.baseModel),this.selectionMethod=e.selectionMethod;else{if("mean"!==(t=Object.assign({},defaultOptions$3,t)).selectionMethod&&"median"!==t.selectionMethod)throw new RangeError("Unsupported selection method ".concat(t.selectionMethod));t.isClassifier=!1,super(t),this.selectionMethod=t.selectionMethod}}selection(t){return selectionMethods[this.selectionMethod](t)}toJSON(){return{baseModel:super.toJSON(),selectionMethod:this.selectionMethod,name:"RFRegression"}}static load(t){if("RFRegression"!==t.name)throw new RangeError("Invalid model: ".concat(t.name));return new RandomForestRegression(!0,t)}}class PCA{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!0===t){const t=e;return this.center=t.center,this.scale=t.scale,this.means=t.means,this.stdevs=t.stdevs,this.U=Matrix.checkMatrix(t.U),void(this.S=t.S)}t=new Matrix(t);const{isCovarianceMatrix:r=!1,center:n=!0,scale:i=!1}=e;if(this.center=n,this.scale=i,this.means=null,this.stdevs=null,r)this._computeFromCovarianceMatrix(t);else if("boolean"==typeof e.useCovarianceMatrix?e.useCovarianceMatrix:t.rows>t.columns){this._adjust(t);const e=new MatrixTransposeView(t).mmul(t).div(t.rows-1);this._computeFromCovarianceMatrix(e)}else{this._adjust(t);var o=new SingularValueDecomposition(t,{computeLeftSingularVectors:!1,computeRightSingularVectors:!0,autoTranspose:!0});this.U=o.rightSingularVectors;const e=o.diagonal,r=[];for(const n of e)r.push(n*n/(t.rows-1));this.S=r}}static load(t){if("string"!=typeof t.name)throw new TypeError("model must have a name property");if("PCA"!==t.name)throw new RangeError("invalid model: ".concat(t.name));return new PCA(!0,t)}predict(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{nComponents:r=this.U.columns}=e;t=new Matrix(t),this.center&&(t.subRowVector(this.means),this.scale&&t.divRowVector(this.stdevs));var n=t.mmul(this.U);return n.subMatrix(0,n.rows-1,0,r-1)}getExplainedVariance(){var t=0;for(const e of this.S)t+=e;return this.S.map(e=>e/t)}getCumulativeVariance(){for(var t=this.getExplainedVariance(),e=1;e<t.length;e++)t[e]+=t[e-1];return t}getEigenvectors(){return this.U}getEigenvalues(){return this.S}getStandardDeviations(){return this.S.map(t=>Math.sqrt(t))}getLoadings(){return this.U.transpose()}toJSON(){return{name:"PCA",center:this.center,scale:this.scale,means:this.means,stdevs:this.stdevs,U:this.U,S:this.S}}_adjust(t){if(this.center){const r=t.mean("column"),n=this.scale?t.standardDeviation("column",{mean:r}):null;if(this.means=r,t.subRowVector(r),this.scale){for(var e=0;e<n.length;e++)if(0===n[e])throw new RangeError("Cannot scale the dataset (standard deviation is zero at index ".concat(e));this.stdevs=n,t.divRowVector(n)}}}_computeFromCovarianceMatrix(t){const e=new EigenvalueDecomposition(t,{assumeSymmetric:!0});this.U=e.eigenvectorMatrix,this.U.flipRows(),this.S=e.realEigenvalues,this.S.reverse()}}function squaredEuclidean(t,e){let r=0;for(let n=0;n<t.length;n++)r+=(t[n]-e[n])*(t[n]-e[n]);return r}function euclidean(t,e){return Math.sqrt(squaredEuclidean(t,e))}var euclidean$1=Object.freeze({squaredEuclidean:squaredEuclidean,euclidean:euclidean});function distanceMatrix(t,e){const r=t.length;let n=Array.from({length:r}).map(()=>Array.from({length:r}));for(let i=0;i<r;i++)for(let r=0;r<=i;r++)n[i][r]=e(t[i],t[r]);for(let t=0;t<r;t++)for(let e=t+1;e<r;e++)n[t][e]=n[e][t];return n}var src$1=distanceMatrix,heap=createCommonjsModule(function(t,e){(function(){var e,r,n,i,o,s,a,h,c,u,l,f,m,g,d;n=Math.floor,u=Math.min,r=function(t,e){return t<e?-1:t>e?1:0},c=function(t,e,i,o,s){var a;if(null==i&&(i=0),null==s&&(s=r),i<0)throw new Error("lo must be non-negative");for(null==o&&(o=t.length);i<o;)s(e,t[a=n((i+o)/2)])<0?o=a:i=a+1;return[].splice.apply(t,[i,i-i].concat(e)),e},s=function(t,e,n){return null==n&&(n=r),t.push(e),g(t,0,t.length-1,n)},o=function(t,e){var n,i;return null==e&&(e=r),n=t.pop(),t.length?(i=t[0],t[0]=n,d(t,0,e)):i=n,i},h=function(t,e,n){var i;return null==n&&(n=r),i=t[0],t[0]=e,d(t,0,n),i},a=function(t,e,n){var i;return null==n&&(n=r),t.length&&n(t[0],e)<0&&(e=(i=[t[0],e])[0],t[0]=i[1],d(t,0,n)),e},i=function(t,e){var i,o,s,a,h,c;for(null==e&&(e=r),h=[],o=0,s=(a=function(){c=[];for(var e=0,r=n(t.length/2);0<=r?e<r:e>r;0<=r?e++:e--)c.push(e);return c}.apply(this).reverse()).length;o<s;o++)i=a[o],h.push(d(t,i,e));return h},m=function(t,e,n){var i;if(null==n&&(n=r),-1!==(i=t.indexOf(e)))return g(t,0,i,n),d(t,i,n)},l=function(t,e,n){var o,s,h,c,u;if(null==n&&(n=r),!(s=t.slice(0,e)).length)return s;for(i(s,n),h=0,c=(u=t.slice(e)).length;h<c;h++)o=u[h],a(s,o,n);return s.sort(n).reverse()},f=function(t,e,n){var s,a,h,l,f,m,g,d,p;if(null==n&&(n=r),10*e<=t.length){if(!(h=t.slice(0,e).sort(n)).length)return h;for(a=h[h.length-1],l=0,m=(g=t.slice(e)).length;l<m;l++)n(s=g[l],a)<0&&(c(h,s,0,null,n),h.pop(),a=h[h.length-1]);return h}for(i(t,n),p=[],f=0,d=u(e,t.length);0<=d?f<d:f>d;0<=d?++f:--f)p.push(o(t,n));return p},g=function(t,e,n,i){var o,s,a;for(null==i&&(i=r),o=t[n];n>e&&i(o,s=t[a=n-1>>1])<0;)t[n]=s,n=a;return t[n]=o},d=function(t,e,n){var i,o,s,a,h;for(null==n&&(n=r),o=t.length,h=e,s=t[e],i=2*e+1;i<o;)(a=i+1)<o&&!(n(t[i],t[a])<0)&&(i=a),t[e]=t[i],i=2*(e=i)+1;return t[e]=s,g(t,h,e,n)},e=function(){function t(t){this.cmp=null!=t?t:r,this.nodes=[]}return t.push=s,t.pop=o,t.replace=h,t.pushpop=a,t.heapify=i,t.updateItem=m,t.nlargest=l,t.nsmallest=f,t.prototype.push=function(t){return s(this.nodes,t,this.cmp)},t.prototype.pop=function(){return o(this.nodes,this.cmp)},t.prototype.peek=function(){return this.nodes[0]},t.prototype.contains=function(t){return-1!==this.nodes.indexOf(t)},t.prototype.replace=function(t){return h(this.nodes,t,this.cmp)},t.prototype.pushpop=function(t){return a(this.nodes,t,this.cmp)},t.prototype.heapify=function(){return i(this.nodes,this.cmp)},t.prototype.updateItem=function(t){return m(this.nodes,t,this.cmp)},t.prototype.clear=function(){return this.nodes=[]},t.prototype.empty=function(){return 0===this.nodes.length},t.prototype.size=function(){return this.nodes.length},t.prototype.clone=function(){var e;return(e=new t).nodes=this.nodes.slice(0),e},t.prototype.toArray=function(){return this.nodes.slice(0)},t.prototype.insert=t.prototype.push,t.prototype.top=t.prototype.peek,t.prototype.front=t.prototype.peek,t.prototype.has=t.prototype.contains,t.prototype.copy=t.prototype.clone,t}(),t.exports=e}).call(commonjsGlobal)}),heap$1=heap;class Cluster{constructor(){this.children=[],this.distance=-1,this.index=[]}cut(t){if(t<0)throw new RangeError("Threshold too small");var e=new Cluster;e.children=this.children,e.distance=this.distance,e.index=this.index;for(var r=[e],n=[];r.length>0;){var i=r.shift();t>=i.distance?n.push(i):r=r.concat(i.children)}return n}group(t){if(!Number.isInteger(t)||t<1)throw new RangeError("Number of groups must be a positive integer");const e=new heap$1(function(t,e){return e.distance-t.distance});for(e.push(this);e.size()<t;){var r=e.pop();if(0===r.children.length)break;r.children.forEach(t=>e.push(t))}var n=new Cluster;return n.children=e.toArray(),n.distance=this.distance,n}traverse(t){!function t(e,r){if(r(e),e.children)for(var n=e.children.length-1;n>=0;n--)t(e.children[n],r)}(this,t)}}class ClusterLeaf extends Cluster{constructor(t){super(),this.index=t,this.distance=0,this.children=[]}}function simpleLink(t,e,r){for(var n=1e101,i=0;i<t.length;i++)for(var o=0;o<e.length;o++){var s=r[t[i]][e[o]];n=Math.min(s,n)}return n}function completeLink(t,e,r){for(var n=-1,i=0;i<t.length;i++)for(var o=0;o<e.length;o++){var s=r[t[i]][e[o]];n=Math.max(s,n)}return n}function averageLink(t,e,r){for(var n=0,i=0;i<t.length;i++)for(var o=0;o<e.length;o++)n+=r[t[i]][e[o]];return n/(t.length*e.length)}function centroidLink(t,e,r){for(var n=new Array(t.length*e.length),i=0;i<t.length;i++)for(var o=0;o<e.length;o++)n[i*e.length+o]=r[t[i]][e[o]];return median$1(n)}function wardLink(t,e,r){return centroidLink(t,e,r)*t.length*e.length/(t.length+e.length)}function compareNumbers$1(t,e){return t-e}function median$1(t,e){void 0===e&&(e=!1),e||(t=[].concat(t).sort(compareNumbers$1));var r=t.length,n=Math.floor(r/2);return r%2==0?.5*(t[n-1]+t[n]):t[n]}function agnes(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{distanceFunction:r=euclidean,method:n="single",isDistanceMatrix:i=!1}=e;let o;var s=t.length,a=t;if(i||(a=src$1(t,r)),"string"==typeof n)switch(n){case"single":o=simpleLink;break;case"complete":o=completeLink;break;case"average":o=averageLink;break;case"centroid":o=centroidLink;break;case"ward":o=wardLink;break;default:throw new RangeError("unknown clustering method: ".concat(n))}else if("function"!=typeof n)throw new TypeError("method must be a string or function");for(var h=new Array(s),c=0;c<a.length;c++)h[c]=new ClusterLeaf(c);for(var u=1e6,l={},f=0;h.length>1;){l={},u=1e6;for(var m=0;m<h.length;m++)for(var g=m+1;g<h.length;g++){var d,p;if(h[m]instanceof ClusterLeaf)d=[h[m].index];else{d=new Array(h[m].index.length);for(var w=0;w<d.length;w++)d[w]=h[m].index[w].index}if(h[g]instanceof ClusterLeaf)p=[h[g].index];else{p=new Array(h[g].index.length);for(var v=0;v<p.length;v++)p[v]=h[g].index[v].index}(f=o(d,p,a).toFixed(4))in l?l[f].push([h[m],h[g]]):l[f]=[[h[m],h[g]]],u=Math.min(f,u)}for(var x=l[u.toFixed(4)],y=new Array(x.length),M=0;x.length>0;){let t=x.shift();const e=function(e){return-1!==t.indexOf(e)},r=function(e){return-1===t.indexOf(e)};for(var b=0;b<x.length;b++){if(x[b].filter(e).length>0){var S=x[b].filter(r);t=t.concat(S),x.splice(b--,1)}}y[M++]=t}y.length=M;for(var A=0;A<y.length;A++){var E=new Cluster;E.children=y[A].concat(),E.distance=u,E.index=new Array(s);for(var R=0,T=0;T<y[A].length;T++)y[A][T]instanceof ClusterLeaf?E.index[R++]=y[A][T]:(R+=y[A][T].index.length,E.index=y[A][T].index.concat(E.index)),h.splice(h.indexOf(y[A][T]),1);E.index.length=R,h.push(E)}}return h[0]}function diff(t,e,r){for(var n={d:0,p:0},i=new Array(t[0].length),o=0;o<t[0].length;o++)i[o]=e[t[0][o]];for(var s,a,h=new Array(t[1].length),c=0;c<t[1].length;c++)h[c]=e[t[1][c]];for(var u=0;u<i.length;u++){s=0;for(var l=0;l<i.length;l++)u!==l&&(s+=r(i[u],i[l]));s/=i.length-1,a=0;for(var f=0;f<h.length;f++)a+=r(i[u],h[f]);s-(a/=h.length)>n.d&&(n.d=s-a,n.p=u)}return n}function intrDist(t,e,r){for(var n=0,i=0,o=0;o<t.length;o++)for(var s=o;s<t.length;s++)n+=r(e[t[o].index],e[t[s].index]),i++;return n/i}function diana(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{distanceFunction:r=euclidean}=e;var n,i,o,s,a,h=new Cluster;h.children=new Array(t.length),h.index=new Array(t.length);for(var c=0;c<t.length;c++)h.children[c]=new ClusterLeaf(c),h.index[c]=new ClusterLeaf(c);h.distance=intrDist(h.index,t,r);for(var u=[h];u.length>0;){i=0,o=0;for(var l=0;l<u.length;l++){n=0;for(var f=0;f<u[l].length;f++)for(var m=f+1;m<u[l].length;m++)n=Math.max(r(t[u[l].index[f].index],t[u[l].index[m].index]),n);n>i&&(i=n,o=l)}if(i=0,2===u[o].index.length)u[o].children=[u[o].index[0],u[o].index[1]],u[o].distance=r(t[u[o].index[0].index],t[u[o].index[1].index]);else if(3===u[o].index.length){u[o].children=[u[o].index[0],u[o].index[1],u[o].index[2]];var g=[r(t[u[o].index[0].index],t[u[o].index[1].index]),r(t[u[o].index[1].index],t[u[o].index[2].index])];u[o].distance=(g[0]+g[1])/2}else{for(var d=new Cluster,p=new Cluster,w=[new Array(u[o].index.length),[]],v=0;v<w[0].length;v++)w[0][v]=v;for(var x=0;x<w[0].length;x++){s=0;for(var y=0;y<w[0].length;y++)x!==y&&(s+=r(t[u[o].index[w[0][y]].index],t[u[o].index[w[0][x]].index]));(s/=w[0].length-1)>i&&(i=s,a=x)}for(w[1]=[a],w[0].splice(a,1),s=diff(w,t,r);s.d>0;)w[1].push(w[0][s.p]),w[0].splice(s.p,1),s=diff(w,t,r);var M=new Array(w[0].length);d.index=new Array(w[0].length);for(var b=0;b<M.length;b++)M[b]=t[u[o].index[w[0][b]].index],d.index[b]=u[o].index[w[0][b]],d.children[b]=u[o].index[w[0][b]];var S=new Array(w[1].length);p.index=new Array(w[1].length);for(var A=0;A<S.length;A++)S[A]=t[u[o].index[w[1][A]].index],p.index[A]=u[o].index[w[1][A]],p.children[A]=u[o].index[w[1][A]];d.distance=intrDist(d.index,t,r),p.distance=intrDist(p.index,t,r),u.push(d),u.push(p),u[o].children=[d,p]}u.splice(o,1)}return h}var index=Object.freeze({agnes:agnes,diana:diana});const defaultOptions$4={distanceFunction:squaredEuclidean};function nearestVector(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:defaultOptions$4;const n=r.distanceFunction||defaultOptions$4.distanceFunction,i=r.similarityFunction||defaultOptions$4.similarityFunction;let o=-1;if("function"==typeof i){let r=Number.MIN_VALUE;for(let n=0;n<t.length;n++){const s=i(e,t[n]);s>r&&(r=s,o=n)}}else{if("function"!=typeof n)throw new Error("A similarity or distance function it's required");{let r=Number.MAX_VALUE;for(let i=0;i<t.length;i++){const s=n(e,t[i]);s<r&&(r=s,o=i)}}}return o}function calculateDistanceMatrix(t,e){for(var r=new Array(t.length),n=0;n<t.length;++n)for(var i=n;i<t.length;++i){r[n]||(r[n]=new Array(t.length)),r[i]||(r[i]=new Array(t.length));const o=e(t[n],t[i]);r[n][i]=o,r[i][n]=o}return r}function updateClusterID(t,e,r,n){for(var i=0;i<t.length;i++)r[i]=nearestVector(e,t[i],{distanceFunction:n});return r}function updateCenters(t,e,r,n){const i=e[0].length;for(var o=new Array(n),s=new Array(n),a=0;a<n;a++){o[a]=new Array(i),s[a]=0;for(var h=0;h<i;h++)o[a][h]=0}for(var c=0;c<e.length;c++){s[r[c]]++;for(var u=0;u<i;u++)o[r[c]][u]+=e[c][u]}for(var l=0;l<n;l++)for(var f=0;f<i;f++)s[l]?o[l][f]/=s[l]:o[l][f]=t[l][f];return o}function hasConverged(t,e,r,n){for(var i=0;i<t.length;i++)if(r(t[i],e[i])>n)return!1;return!0}const LOOP=8,FLOAT_MUL=1/16777216,sh1=15,sh2=18,sh3=11;function multiply_uint32(t,e){const r=65535&(t>>>=0);return((t-r)*(e>>>=0)>>>0)+r*e>>>0}class XSadd{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Date.now();this.state=new Uint32Array(4),this.init(t),this.random=this.getFloat.bind(this)}getUint32(){return this.nextState(),this.state[3]+this.state[2]>>>0}getFloat(){return(this.getUint32()>>>8)*FLOAT_MUL}init(t){if(!Number.isInteger(t))throw new TypeError("seed must be an integer");this.state[0]=t,this.state[1]=0,this.state[2]=0,this.state[3]=0;for(let t=1;t<LOOP;t++)this.state[3&t]^=t+multiply_uint32(1812433253,this.state[t-1&3]^this.state[t-1&3]>>>30>>>0)>>>0;this.periodCertification();for(let t=0;t<LOOP;t++)this.nextState()}periodCertification(){0===this.state[0]&&0===this.state[1]&&0===this.state[2]&&0===this.state[3]&&(this.state[0]=88,this.state[1]=83,this.state[2]=65,this.state[3]=68)}nextState(){let t=this.state[0];t^=t<<sh1,t^=t>>>sh2,t^=this.state[3]<<sh3,this.state[0]=this.state[1],this.state[1]=this.state[2],this.state[2]=this.state[3],this.state[3]=t}}const PROB_TOLERANCE=1e-8;function randomChoice(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Math.random;const{size:n=1,replace:i=!1,probabilities:o}=e;let s,a;if(s="number"==typeof t?getArray(t):t.slice(),o){if(!i)throw new Error("choice with probabilities and no replacement is not implemented");if(o.length!==s.length)throw new Error("the length of probabilities option should be equal to the number of choices");a=[o[0]];for(let t=1;t<o.length;t++)a[t]=a[t-1]+o[t];if(Math.abs(1-a[a.length-1])>PROB_TOLERANCE)throw new Error("probabilities should sum to 1, but instead sums to ".concat(a[a.length-1]))}if(!1===i&&n>s.length)throw new Error("size option is too large");const h=[];for(let t=0;t<n;t++){const t=randomIndex(s.length,r,a);h.push(s[t]),i||s.splice(t,1)}return h}function getArray(t){const e=[];for(let r=0;r<t;r++)e.push(r);return e}function randomIndex(t,e,r){const n=e();if(r){let t=0;for(;n>r[t];)t++;return t}return Math.floor(n*t)}class Random{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Math.random;if("number"==typeof t){const e=new XSadd(t);this.randomGenerator=e.random}else this.randomGenerator=t}choice(t,e){return randomChoice(t,e,this.randomGenerator)}random(){return this.randomGenerator()}randInt(t,e){return void 0===e&&(e=t,t=0),t+Math.floor(this.randomGenerator()*(e-t))}randomSample(t){const e=[];for(let r=0;r<t;r++)e.push(this.random());return e}}function random(t,e,r){return new Random(r).choice(t,{size:e})}function mostDistant(t,e,r,n){const i=new Random(n);var o=new Array(e);if(o[0]=Math.floor(i.random()*t.length),e>1){for(var s={dist:-1,index:-1},a=0;a<t.length;++a)r[o[0]][a]>s.dist&&(s.dist=r[o[0]][a],s.index=a);if(o[1]=s.index,e>2)for(var h=2;h<e;++h){for(var c={dist:-1,index:-1},u=0;u<t.length;++u){for(var l={dist:Number.MAX_VALUE,index:-1},f=0;f<h;++f)r[f][u]<l.dist&&-1===o.indexOf(u)&&(l={dist:r[f][u],index:u});l.dist!==Number.MAX_VALUE&&l.dist>c.dist&&(c=Object.assign({},l))}o[h]=c.index}}return o.map(e=>t[e])}function kmeanspp(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const n=(t=new Matrix(t)).rows,i=new Random(r.seed),o=[],s=r.localTrials||2+Math.floor(Math.log(e)),a=i.randInt(n);o.push(t.getRow(a));let h=new Matrix(1,t.rows);for(let e=0;e<t.rows;e++)h.set(0,e,squaredEuclidean(t.getRow(e),o[0]));let c=[cumSum(h.getRow(0))];const u=1/c[0][n-1];let l=Matrix.mul(h,u);for(let r=1;r<e;r++){const e=i.choice(n,{replace:!0,size:s,probabilities:l[0]}),a=euclideanDistances(t.selection(e,range(t.columns)),t);let u,f,m;for(let t=0;t<s;t++){const r=Matrix.min(h,[a.getRow(t)]),n=r.sum();(void 0===u||n<f)&&(u=e[t],f=n,m=r)}o[r]=t.getRow(u),c=[cumSum((h=m).getRow(0))],l=Matrix.mul(h,1/c[0][n-1])}return o}function euclideanDistances(t,e){const r=new Matrix(t.rows,e.rows);for(let n=0;n<t.rows;n++)for(let i=0;i<e.rows;i++)r.set(n,i,squaredEuclidean(t.getRow(n),e.getRow(i)));return r}function range(t){let e=[];for(let r=0;r<t;r++)e.push(r);return e}function cumSum(t){let e=[t[0]];for(let r=1;r<t.length;r++)e[r]=e[r-1]+t[r];return e}const distanceSymbol=Symbol("distance");class KMeansResult{constructor(t,e,r,n,i){this.clusters=t,this.centroids=e,this.converged=r,this.iterations=n,this[distanceSymbol]=i}nearest(t){const e=new Array(t.length);return updateClusterID(t,this.centroids.map(function(t){return t.centroid}),e,this[distanceSymbol])}computeInformation(t){for(var e=this.centroids.map(function(t){return{centroid:t,error:0,size:0}}),r=0;r<t.length;r++)e[this.clusters[r]].error+=this[distanceSymbol](t[r],this.centroids[this.clusters[r]]),e[this.clusters[r]].size++;for(var n=0;n<this.centroids.length;n++)e[n].size?e[n].error/=e[n].size:e[n].error=null;return new KMeansResult(this.clusters,e,this.converged,this.iterations,this[distanceSymbol])}}const defaultOptions$5={maxIterations:100,tolerance:1e-6,withIterations:!1,initialization:"kmeans++",distanceFunction:squaredEuclidean};function step(t,e,r,n,i,o){var s=updateCenters(t,e,r=updateClusterID(e,t,r,i.distanceFunction),n),a=hasConverged(s,t,i.distanceFunction,i.tolerance);return new KMeansResult(r,s,a,o,i.distanceFunction)}function*kmeansGenerator(t,e,r,n,i){for(var o,s=!1,a=0;!s&&a<i.maxIterations;)o=step(t,e,r,n,i,++a),yield o.computeInformation(e),s=o.converged,t=o.centroids}function kmeans(t,e,r){if(r=Object.assign({},defaultOptions$5,r),e<=0||e>t.length||!Number.isInteger(e))throw new Error("K should be a positive integer smaller than the number of points");var n;if(Array.isArray(r.initialization)){if(r.initialization.length!==e)throw new Error("The initial centers should have the same length as K");n=r.initialization}else switch(r.initialization){case"kmeans++":n=kmeanspp(t,e,r);break;case"random":n=random(t,e,r.seed);break;case"mostDistant":n=mostDistant(t,e,calculateDistanceMatrix(t,r.distanceFunction),r.seed);break;default:throw new Error('Unknown initialization method: "'.concat(r.initialization,'"'))}0===r.maxIterations&&(r.maxIterations=Number.MAX_VALUE);var i=new Array(t.length);if(r.withIterations)return kmeansGenerator(n,t,i,e,r);for(var o,s=!1,a=0;!s&&a<r.maxIterations;)s=(o=step(n,t,i,e,r,++a)).converged,n=o.centroids;return o.computeInformation(t)}function separateClasses(t,e){for(var r=t.columns,n=0,i=new Array(1e4),o=0;o<e.length;o++)void 0===i[e[o]]&&(i[e[o]]=0,n++),i[e[o]]++;var s=new Array(n),a=new Array(n);for(o=0;o<n;++o)s[o]=new Matrix(i[o],r),a[o]=0;for(o=0;o<t.rows;++o)s[e[o]].setRow(a[e[o]],t.getRow(o)),a[e[o]]++;return s}class GaussianNB{constructor(t,e){t&&(this.means=e.means,this.calculateProbabilities=e.calculateProbabilities)}train(t,e){var r=Math.sqrt(2*Math.PI);if((t=Matrix.checkMatrix(t)).rows!==e.length)throw new RangeError("the size of the training set and the training labels must be the same.");var n=separateClasses(t,e),i=new Array(n.length);this.means=new Array(n.length);for(var o=0;o<n.length;++o){var s=n[o].mean("column"),a=n[o].standardDeviation("column",{mean:s}),h=Math.log(n[o].rows/t.rows);i[o]=new Array(s.length+1),i[o][0]=h;for(var c=1;c<s.length+1;++c){var u=a[c-1];i[o][c]=[1/(r*u),-2*u*u]}this.means[o]=s}this.calculateProbabilities=i}predict(t){if((t=Matrix.checkMatrix(t)).rows===this.calculateProbabilities[0].length)throw new RangeError("the dataset must have the same features as the training set");for(var e=new Array(t.rows),r=0;r<e.length;++r)e[r]=getCurrentClass(t.getRow(r),this.means,this.calculateProbabilities);return e}toJSON(){return{modelName:"NaiveBayes",means:this.means,calculateProbabilities:this.calculateProbabilities}}static load(t){if("NaiveBayes"!==t.modelName)throw new RangeError("The current model is not a Multinomial Naive Bayes, current model:",t.name);return new GaussianNB(!0,t)}}function getCurrentClass(t,e,r){for(var n=0,i=-1,o=0;o<r.length;++o){for(var s=r[o][0],a=1;a<r[0][1].length+1;++a)s+=calculateLogProbability(t[a-1],e[o][a-1],r[o][a][0],r[o][a][1]);(s=Math.exp(s))>n&&(n=s,i=o)}return i}function calculateLogProbability(t,e,r,n){return t-=e,Math.log(r*Math.exp(t*t/n))}class MultinomialNB{constructor(t){t&&(this.conditionalProbability=Matrix.checkMatrix(t.conditionalProbability),this.priorProbability=Matrix.checkMatrix(t.priorProbability))}train(t,e){if((t=Matrix.checkMatrix(t)).rows!==e.length)throw new RangeError("the size of the training set and the training labels must be the same.");var r=separateClasses(t,e);this.priorProbability=new Matrix(r.length,1);for(var n=0;n<r.length;++n)this.priorProbability.set(n,0,Math.log(r[n].rows/t.rows));var i=t.columns;for(this.conditionalProbability=new Matrix(r.length,i),n=0;n<r.length;++n){var o=Matrix.checkMatrix(r[n]),s=o.sum()+i;this.conditionalProbability.setRow(n,Matrix.rowVector(o.sum("column")).add(1).div(s).apply(matrixLog))}}predict(t){t=Matrix.checkMatrix(t);for(var e=new Array(t.rows),r=0;r<t.rows;++r){var n=t.getRowVector(r);const i=Matrix.columnVector(this.conditionalProbability.clone().mulRowVector(n).sum("row"));e[r]=i.add(this.priorProbability).maxIndex()[0]}return e}toJSON(){return{name:"MultinomialNB",priorProbability:this.priorProbability,conditionalProbability:this.conditionalProbability}}static load(t){if("MultinomialNB"!==t.name)throw new RangeError("".concat(t.name," is not a Multinomial Naive Bayes"));return new MultinomialNB(t)}}function matrixLog(t,e){this.set(t,e,Math.log(this.get(t,e)))}var index$1=Object.freeze({GaussianNB:GaussianNB,MultinomialNB:MultinomialNB});function Node(t,e,r){this.obj=t,this.left=null,this.right=null,this.parent=r,this.dimension=e}class KDTree{constructor(t,e){if(Array.isArray(t)){this.dimensions=new Array(t[0].length);for(var r=0;r<this.dimensions.length;r++)this.dimensions[r]=r;this.root=buildTree(t,0,null,this.dimensions)}else this.dimensions=t.dimensions,this.root=t,restoreParent(this.root);this.metric=e}toJSON(){const t=toJSONImpl(this.root);return t.dimensions=this.dimensions,t}nearest(t,e,r){const n=this.metric,i=this.dimensions;var o;const s=new BinaryHeap(function(t){return-t[1]});if(r)for(o=0;o<e;o+=1)s.push([null,r]);this.root&&function r(o){const a=i[o.dimension],h=n(t,o.obj),c={};var u,l,f,m;function g(t,r){s.push([t,r]),s.size()>e&&s.pop()}for(m=0;m<i.length;m+=1)m===o.dimension?c[i[m]]=t[i[m]]:c[i[m]]=o.obj[i[m]];l=n(c,o.obj),null!==o.right||null!==o.left?(r(u=null===o.right?o.left:null===o.left?o.right:t[a]<o.obj[a]?o.left:o.right),(s.size()<e||h<s.peek()[1])&&g(o,h),(s.size()<e||Math.abs(l)<s.peek()[1])&&null!==(f=u===o.left?o.right:o.left)&&r(f)):(s.size()<e||h<s.peek()[1])&&g(o,h)}(this.root);const a=[];for(o=0;o<Math.min(e,s.content.length);o+=1)s.content[o][0]&&a.push([s.content[o][0].obj,s.content[o][1]]);return a}}function toJSONImpl(t){const e=new Node(t.obj,t.dimension,null);return t.left&&(e.left=toJSONImpl(t.left)),t.right&&(e.right=toJSONImpl(t.right)),e}function buildTree(t,e,r,n){const i=e%n.length;if(0===t.length)return null;if(1===t.length)return new Node(t[0],i,r);t.sort((t,e)=>t[n[i]]-e[n[i]]);const o=Math.floor(t.length/2),s=new Node(t[o],i,r);return s.left=buildTree(t.slice(0,o),e+1,s,n),s.right=buildTree(t.slice(o+1),e+1,s,n),s}function restoreParent(t){t.left&&(t.left.parent=t,restoreParent(t.left)),t.right&&(t.right.parent=t,restoreParent(t.right))}class BinaryHeap{constructor(t){this.content=[],this.scoreFunction=t}push(t){this.content.push(t),this.bubbleUp(this.content.length-1)}pop(){var t=this.content[0],e=this.content.pop();return this.content.length>0&&(this.content[0]=e,this.sinkDown(0)),t}peek(){return this.content[0]}size(){return this.content.length}bubbleUp(t){for(var e=this.content[t];t>0;){const r=Math.floor((t+1)/2)-1,n=this.content[r];if(!(this.scoreFunction(e)<this.scoreFunction(n)))break;this.content[r]=e,this.content[t]=n,t=r}}sinkDown(t){for(var e=this.content.length,r=this.content[t],n=this.scoreFunction(r);;){var i=2*(t+1),o=i-1,s=null;if(o<e){var a=this.content[o],h=this.scoreFunction(a);h<n&&(s=o)}if(i<e){var c=this.content[i];this.scoreFunction(c)<(null===s?n:h)&&(s=i)}if(null===s)break;this.content[t]=this.content[s],this.content[s]=r,t=s}}}class KNN{constructor(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!0===t){const t=e;return this.kdTree=new KDTree(t.kdTree,r),this.k=t.k,this.classes=new Set(t.classes),void(this.isEuclidean=t.isEuclidean)}const n=new Set(e),{distance:i=euclidean,k:o=n.size+1}=r,s=new Array(t.length);for(var a=0;a<s.length;++a)s[a]=t[a].slice();for(a=0;a<e.length;++a)s[a].push(e[a]);this.kdTree=new KDTree(s,i),this.k=o,this.classes=n,this.isEuclidean=i===euclidean}static load(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:euclidean;if("KNN"!==t.name)throw new Error("invalid model: ".concat(t.name));if(!t.isEuclidean&&e===euclidean)throw new Error("a custom distance function was used to create the model. Please provide it again");if(t.isEuclidean&&e!==euclidean)throw new Error("the model was created with the default distance function. Do not load it with another one");return new KNN(!0,t,e)}toJSON(){return{name:"KNN",kdTree:this.kdTree,k:this.k,classes:Array.from(this.classes),isEuclidean:this.isEuclidean}}predict(t){if(Array.isArray(t)){if("number"==typeof t[0])return getSinglePrediction(this,t);if(Array.isArray(t[0])&&"number"==typeof t[0][0]){const r=new Array(t.length);for(var e=0;e<t.length;e++)r[e]=getSinglePrediction(this,t[e]);return r}}throw new TypeError("dataset to predict must be an array or a matrix")}}function getSinglePrediction(t,e){var r=t.kdTree.nearest(e,t.k),n={},i=-1,o=-1,s=r[0][0].length-1;for(var a of t.classes)n[a]=0;for(var h=0;h<r.length;++h){var c=r[h][0][s],u=++n[c];u>o&&(i=c,o=u)}return i}function norm(t){return Math.sqrt(t.clone().apply(pow2array).sum())}function pow2array(t,e){this.set(t,e,this.get(t,e)**2)}function initializeMatrices(t,e){if(e)for(var r=0;r<t.length;++r)for(var n=0;n<t[r].length;++n){var i=t[r][n];t[r][n]=null!==i?new Matrix(t[r][n]):void 0}else for(r=0;r<t.length;++r)t[r]=new Matrix(t[r]);return t}class PLS{constructor(t,e){if(!0===t)this.meanX=e.meanX,this.stdDevX=e.stdDevX,this.meanY=e.meanY,this.stdDevY=e.stdDevY,this.PBQ=Matrix.checkMatrix(e.PBQ),this.R2X=e.R2X,this.scale=e.scale,this.scaleMethod=e.scaleMethod,this.tolerance=e.tolerance;else{var{tolerance:r=1e-5,scale:n=!0}=t;this.tolerance=r,this.scale=n,this.latentVectors=t.latentVectors}}train(t,e){if(t=Matrix.checkMatrix(t),e=Matrix.checkMatrix(e),t.length!==e.length)throw new RangeError("The number of X rows must be equal to the number of Y rows");this.meanX=t.mean("column"),this.stdDevX=t.standardDeviation("column",{mean:this.meanX,unbiased:!0}),this.meanY=e.mean("column"),this.stdDevY=e.standardDeviation("column",{mean:this.meanY,unbiased:!0}),this.scale&&(t=t.clone().subRowVector(this.meanX).divRowVector(this.stdDevX),e=e.clone().subRowVector(this.meanY).divRowVector(this.stdDevY)),void 0===this.latentVectors&&(this.latentVectors=Math.min(t.rows-1,t.columns));for(var r=t.rows,n=t.columns,i=e.rows,o=e.columns,s=t.clone().mul(t).sum(),a=e.clone().mul(e).sum(),h=this.tolerance,c=this.latentVectors,u=Matrix.zeros(r,c),l=Matrix.zeros(n,c),f=Matrix.zeros(i,c),m=Matrix.zeros(o,c),g=Matrix.zeros(c,c),d=l.clone(),p=0;norm(e)>h&&p<c;){for(var w=t.transpose(),v=e.transpose(),x=maxSumColIndex(t.clone().mul(t)),y=maxSumColIndex(e.clone().mul(e)),M=t.getColumnVector(x),b=e.getColumnVector(y),S=Matrix.zeros(r,1);norm(M.clone().sub(S))>h;){var A=w.mmul(b);A.div(norm(A)),S=M,M=t.mmul(A);var E=v.mmul(M);E.div(norm(E)),b=e.mmul(E)}S=M;var R=w.mmul(S),T=S.transpose().mmul(S).get(0,0),k=R.div(T),N=norm(k);k.div(N),S.mul(N),A.mul(N),R=b.transpose().mmul(S),T=S.transpose().mmul(S).get(0,0);var C=R.div(T).get(0,0);t.sub(S.mmul(k.transpose())),e.sub(S.clone().mul(C).mmul(E.transpose())),u.setColumn(p,S),l.setColumn(p,k),f.setColumn(p,b),m.setColumn(p,E),d.setColumn(p,A),g.set(p,p,C),p++}p--,u=u.subMatrix(0,u.rows-1,0,p),l=l.subMatrix(0,l.rows-1,0,p),f=f.subMatrix(0,f.rows-1,0,p),m=m.subMatrix(0,m.rows-1,0,p),d=d.subMatrix(0,d.rows-1,0,p),g=g.subMatrix(0,p,0,p),this.ssqYcal=a,this.E=t,this.F=e,this.T=u,this.P=l,this.U=f,this.Q=m,this.W=d,this.B=g,this.PBQ=l.mmul(g).mmul(m.transpose()),this.R2X=S.transpose().mmul(S).mmul(k.transpose().mmul(k)).div(s).get(0,0)}predict(t){var e=Matrix.checkMatrix(t);this.scale&&(e=e.subRowVector(this.meanX).divRowVector(this.stdDevX));var r=e.mmul(this.PBQ);return r=r.mulRowVector(this.stdDevY).addRowVector(this.meanY)}getExplainedVariance(){return this.R2X}toJSON(){return{name:"PLS",R2X:this.R2X,meanX:this.meanX,stdDevX:this.stdDevX,meanY:this.meanY,stdDevY:this.stdDevY,PBQ:this.PBQ,tolerance:this.tolerance,scale:this.scale}}static load(t){if("PLS"!==t.name)throw new RangeError("Invalid model: ".concat(t.name));return new PLS(!0,t)}}function maxSumColIndex(t){return Matrix.rowVector(t.sum("column")).maxIndex()[0]}class KOPLS{constructor(t,e){if(!0===t)this.trainingSet=new Matrix(e.trainingSet),this.YLoadingMat=new Matrix(e.YLoadingMat),this.SigmaPow=new Matrix(e.SigmaPow),this.YScoreMat=new Matrix(e.YScoreMat),this.predScoreMat=initializeMatrices(e.predScoreMat,!1),this.YOrthLoadingVec=initializeMatrices(e.YOrthLoadingVec,!1),this.YOrthEigen=e.YOrthEigen,this.YOrthScoreMat=initializeMatrices(e.YOrthScoreMat,!1),this.toNorm=initializeMatrices(e.toNorm,!1),this.TURegressionCoeff=initializeMatrices(e.TURegressionCoeff,!1),this.kernelX=initializeMatrices(e.kernelX,!0),this.kernel=e.kernel,this.orthogonalComp=e.orthogonalComp,this.predictiveComp=e.predictiveComp;else{if(void 0===t.predictiveComponents)throw new RangeError("no predictive components found!");if(void 0===t.orthogonalComponents)throw new RangeError("no orthogonal components found!");if(void 0===t.kernel)throw new RangeError("no kernel found!");this.orthogonalComp=t.orthogonalComponents,this.predictiveComp=t.predictiveComponents,this.kernel=t.kernel}}train(t,e){t=Matrix.checkMatrix(t),e=Matrix.checkMatrix(e),this.trainingSet=t.clone();var r=this.kernel.compute(t),n=Matrix.eye(r.rows,r.rows,1),i=r;r=new Array(this.orthogonalComp+1);for(let t=0;t<this.orthogonalComp+1;t++)r[t]=new Array(this.orthogonalComp+1);r[0][0]=i;var o=new SingularValueDecomposition(e.transpose().mmul(r[0][0]).mmul(e),{computeLeftSingularVectors:!0,computeRightSingularVectors:!1}),s=o.leftSingularVectors,a=o.diagonalMatrix;s=s.subMatrix(0,s.rows-1,0,this.predictiveComp-1),a=a.subMatrix(0,this.predictiveComp-1,0,this.predictiveComp-1);var h=e.mmul(s),c=new Array(this.orthogonalComp+1),u=new Array(this.orthogonalComp+1),l=new Array(this.orthogonalComp),f=new Array(this.orthogonalComp),m=new Array(this.orthogonalComp),g=new Array(this.orthogonalComp),d=Matrix.pow(a,-.5);d.apply(function(t,e){this.get(t,e)===1/0&&this.set(t,e,0)});for(var p=0;p<this.orthogonalComp;++p){c[p]=r[0][p].transpose().mmul(h).mmul(d);var w=c[p].transpose();u[p]=inverse(w.mmul(c[p])).mmul(w).mmul(h);var v=(o=new SingularValueDecomposition(w.mmul(Matrix.sub(r[p][p],c[p].mmul(w))).mmul(c[p]),{computeLeftSingularVectors:!0,computeRightSingularVectors:!1})).leftSingularVectors,x=o.diagonalMatrix;f[p]=v.subMatrix(0,v.rows-1,0,0),m[p]=x.get(0,0),l[p]=Matrix.sub(r[p][p],c[p].mmul(w)).mmul(c[p]).mmul(f[p]).mul(Math.pow(m[p],-.5));var y=l[p].transpose();g[p]=Matrix.sqrt(y.mmul(l[p])),l[p]=l[p].divRowVector(g[p]);var M=Matrix.sub(n,l[p].mmul(l[p].transpose()));r[0][p+1]=r[0][p].mmul(M),r[p+1][p+1]=M.mmul(r[p][p]).mmul(M)}var b=c[this.orthogonalComp]=r[0][this.orthogonalComp].transpose().mmul(h).mmul(d),S=b.transpose();u[this.orthogonalComp]=inverse(S.mmul(b)).mmul(S).mmul(h),this.YLoadingMat=s,this.SigmaPow=d,this.YScoreMat=h,this.predScoreMat=c,this.YOrthLoadingVec=f,this.YOrthEigen=m,this.YOrthScoreMat=l,this.toNorm=g,this.TURegressionCoeff=u,this.kernelX=r}predict(t){var e=this.kernel.compute(t,this.trainingSet),r=e;e=new Array(this.orthogonalComp+1);for(let t=0;t<this.orthogonalComp+1;t++)e[t]=new Array(this.orthogonalComp+1);e[0][0]=r;var n,i=new Array(this.orthogonalComp),o=new Array(this.orthogonalComp);for(n=0;n<this.orthogonalComp;++n){o[n]=e[n][0].mmul(this.YScoreMat).mmul(this.SigmaPow),i[n]=Matrix.sub(e[n][n],o[n].mmul(this.predScoreMat[n].transpose())).mmul(this.predScoreMat[n]).mmul(this.YOrthLoadingVec[n]).mul(Math.pow(this.YOrthEigen[n],-.5)),i[n]=i[n].divRowVector(this.toNorm[n]);var s=this.YOrthScoreMat[n].transpose();e[n+1][0]=Matrix.sub(e[n][0],i[n].mmul(s).mmul(this.kernelX[0][n].transpose()));var a=Matrix.sub(e[n][0],e[n][n].mmul(this.YOrthScoreMat[n]).mmul(s)),h=i[n].mmul(s).mmul(this.kernelX[n][n]),c=h.mmul(this.YOrthScoreMat[n]).mmul(s);e[n+1][n+1]=a.sub(h).add(c)}return o[n]=e[n][0].mmul(this.YScoreMat).mmul(this.SigmaPow),{prediction:o[n].mmul(this.TURegressionCoeff[n]).mmul(this.YLoadingMat.transpose()),predScoreMat:o,predYOrthVectors:i}}toJSON(){return{name:"K-OPLS",YLoadingMat:this.YLoadingMat,SigmaPow:this.SigmaPow,YScoreMat:this.YScoreMat,predScoreMat:this.predScoreMat,YOrthLoadingVec:this.YOrthLoadingVec,YOrthEigen:this.YOrthEigen,YOrthScoreMat:this.YOrthScoreMat,toNorm:this.toNorm,TURegressionCoeff:this.TURegressionCoeff,kernelX:this.kernelX,trainingSet:this.trainingSet,orthogonalComp:this.orthogonalComp,predictiveComp:this.predictiveComp}}static load(t,e){if("K-OPLS"!==t.name)throw new RangeError("Invalid model: ".concat(t.name));if(!e)throw new RangeError("You must provide a kernel for the model!");return t.kernel=e,new KOPLS(!0,t)}}class ConfusionMatrix{constructor(t,e){if(t.length!==t[0].length)throw new Error("Confusion matrix must be square");if(e.length!==t.length)throw new Error("Confusion matrix and labels should have the same length");this.labels=e,this.matrix=t}static fromLabels(t,e){let r,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(e.length!==t.length)throw new Error("predicted and actual must have the same length");r=n.labels?new Set(n.labels):new Set([...t,...e]),r=Array.from(r),n.sort&&r.sort(n.sort);const i=Array.from({length:r.length});for(let t=0;t<i.length;t++)i[t]=new Array(i.length),i[t].fill(0);for(let n=0;n<e.length;n++){const o=r.indexOf(t[n]),s=r.indexOf(e[n]);o>=0&&s>=0&&i[o][s]++}return new ConfusionMatrix(i,r)}getMatrix(){return this.matrix}getLabels(){return this.labels}getTotalCount(){let t=0;for(var e=0;e<this.matrix.length;e++)for(var r=0;r<this.matrix.length;r++)t+=this.matrix[e][r];return t}getTrueCount(){for(var t=0,e=0;e<this.matrix.length;e++)t+=this.matrix[e][e];return t}getFalseCount(){return this.getTotalCount()-this.getTrueCount()}getTruePositiveCount(t){const e=this.getIndex(t);return this.matrix[e][e]}getTrueNegativeCount(t){const e=this.getIndex(t);for(var r=0,n=0;n<this.matrix.length;n++)for(var i=0;i<this.matrix.length;i++)n!==e&&i!==e&&(r+=this.matrix[n][i]);return r}getFalsePositiveCount(t){const e=this.getIndex(t);for(var r=0,n=0;n<this.matrix.length;n++)n!==e&&(r+=this.matrix[n][e]);return r}getFalseNegativeCount(t){const e=this.getIndex(t);for(var r=0,n=0;n<this.matrix.length;n++)n!==e&&(r+=this.matrix[e][n]);return r}getPositiveCount(t){return this.getTruePositiveCount(t)+this.getFalseNegativeCount(t)}getNegativeCount(t){return this.getTrueNegativeCount(t)+this.getFalsePositiveCount(t)}getIndex(t){const e=this.labels.indexOf(t);if(-1===e)throw new Error("The label does not exist");return e}getTruePositiveRate(t){return this.getTruePositiveCount(t)/this.getPositiveCount(t)}getTrueNegativeRate(t){return this.getTrueNegativeCount(t)/this.getNegativeCount(t)}getPositivePredictiveValue(t){const e=this.getTruePositiveCount(t);return e/(e+this.getFalsePositiveCount(t))}getNegativePredictiveValue(t){const e=this.getTrueNegativeCount(t);return e/(e+this.getFalseNegativeCount(t))}getFalseNegativeRate(t){return 1-this.getTruePositiveRate(t)}getFalsePositiveRate(t){return 1-this.getTrueNegativeRate(t)}getFalseDiscoveryRate(t){const e=this.getFalsePositiveCount(t);return e/(e+this.getTruePositiveCount(t))}getFalseOmissionRate(t){const e=this.getFalseNegativeCount(t);return e/(e+this.getTruePositiveCount(t))}getF1Score(t){const e=this.getTruePositiveCount(t);return 2*e/(2*e+this.getFalsePositiveCount(t)+this.getFalseNegativeCount(t))}getMatthewsCorrelationCoefficient(t){const e=this.getTruePositiveCount(t),r=this.getTrueNegativeCount(t),n=this.getFalsePositiveCount(t),i=this.getFalseNegativeCount(t);return(e*r-n*i)/Math.sqrt((e+n)*(e+i)*(r+n)*(r+i))}getInformedness(t){return this.getTruePositiveRate(t)+this.getTrueNegativeRate(t)-1}getMarkedness(t){return this.getPositivePredictiveValue(t)+this.getNegativePredictiveValue(t)-1}getConfusionTable(t){return[[this.getTruePositiveCount(t),this.getFalseNegativeCount(t)],[this.getFalsePositiveCount(t),this.getTrueNegativeCount(t)]]}getAccuracy(){let t=0,e=0;for(var r=0;r<this.matrix.length;r++)for(var n=0;n<this.matrix.length;n++)r===n?t+=this.matrix[r][n]:e+=this.matrix[r][n];return t/(t+e)}getCount(t,e){const r=this.getIndex(t),n=this.getIndex(e);return this.matrix[r][n]}get accuracy(){return this.getAccuracy()}get total(){return this.getTotalCount()}}var src$2=ConfusionMatrix;const defaultOptions$6={mode:"index"};var src$3=function*(t,e,r){r=Object.assign({},defaultOptions$6,r);for(var n,i,o,s=new Array(e),a=new Array(t),h=new Array(e),c=new Array(e+2),u=0;u<e;u++)s[u]=u,h[u]=u<e-t?0:1;for(u=0;u<t;u++)a[u]=e-t+u;for(u=0;u<c.length;u++)c[u]=0===u?e+1:u<=e-t?0:u<=e?u-e+t:-2;function l(){var t,e,r;for(e=1;c[e]<=0;)e++;if(0===c[e-1]){for(t=e-1;1!==t;t--)c[t]=-1;c[e]=0,n=o=0,c[1]=1,i=e-1}else{e>1&&(c[e-1]=0);do{e++}while(c[e]>0);for(r=e-1,t=e;0===c[t];)c[t++]=-1;if(-1===c[t])c[t]=c[r],o=c[r]-1,n=t-1,i=r-1,c[r]=-1;else{if(t===c[0])return 0;c[e]=c[t],o=c[t]-1,c[t]=0,n=e-1,i=t-1}}return 1}if("index"===r.mode)for(yield a.slice();l();)a[o]=s[n],yield a.slice();else{if("mask"!==r.mode)throw new Error("Invalid mode");for(yield h.slice();l();)h[n]=1,h[i]=0,yield h.slice()}};const CV={};function check(t,e){if(t.length!==e.length)throw new Error("features and labels should have the same length")}function initMatrix(t,e){return new Array(t).fill(0).map(()=>new Array(e).fill(0))}function getDistinct(t){var e=new Set;for(let r=0;r<t.length;r++)e.add(t[r]);return Array.from(e)}function validate(t,e,r,n,i,o,s,a){const{testFeatures:h,trainFeatures:c,testLabels:u,trainLabels:l}=getTrainTest(e,r,i,o);var f;t.prototype.train?(f=new t(n)).train(c,l):f=new t(c,l,n),updateConfusionMatrix(s,u,f.predict(h),a)}function validateWithCallback(t,e,r,n,i,o,s){const{testFeatures:a,trainFeatures:h,testLabels:c,trainLabels:u}=getTrainTest(t,e,r,n);updateConfusionMatrix(i,c,s(h,u,a),o)}function updateConfusionMatrix(t,e,r,n){for(var i=0;i<r.length;i++){const o=n.indexOf(e[i]),s=n.indexOf(r[i]);(o<0||s<0)&&console.warn("ignore unknown predicted label ".concat(r[i])),t[o][s]++}}function getTrainTest(t,e,r,n){return{testFeatures:r.map(function(e){return t[e]}),trainFeatures:n.map(function(e){return t[e]}),testLabels:r.map(function(t){return e[t]}),trainLabels:n.map(function(t){return e[t]})}}CV.leaveOneOut=function(t,e,r,n){if("function"==typeof r){var i=r;return r=e,e=t,CV.leavePOut(e,r,1,i)}return CV.leavePOut(t,e,r,n,1)},CV.leavePOut=function(t,e,r,n,i){if("function"==typeof n){var o=n;i=r,r=e,e=t}check(e,r);const s=getDistinct(r),a=initMatrix(s.length,s.length);var h=e.length,c=src$3(i,h),u=new Array(h);for(let t=0;t<h;t++)u[t]=t;for(const i of c){var l=u.slice();for(let t=i.length-1;t>=0;t--)l.splice(i[t],1);o?validateWithCallback(e,r,i,l,a,s,o):validate(t,e,r,n,i,l,a,s)}return new src$2(a,s)},CV.kFold=function(t,e,r,n,i){if("function"==typeof n){var o=n;i=r,r=e,e=t}check(e,r);const s=getDistinct(r),a=initMatrix(s.length,s.length);for(var h=e.length,c=new Array(h),u=0;u<h;u++)c[u]=u;for(var l=Math.floor(h/i),f=[],m=[];c.length;){var g=Math.floor(Math.random()*c.length);f.push(c[g]),c.splice(g,1),f.length===l&&(m.push(f),f=[])}for(f.length&&m.push(f),m=m.slice(0,i),u=0;u<m.length;u++){for(var d=m[u],p=[],w=0;w<m.length;w++)w!==u&&(p=p.concat(m[w]));o?validateWithCallback(e,r,d,p,a,s,o):validate(t,e,r,n,d,p,a,s)}return new src$2(a,s)};var src$4=CV;function logistic(t){return 1/(1+Math.exp(-t))}function expELU(t,e){return t<0?e*(Math.exp(t)-1):t}function softExponential(t,e){return e<0?-Math.log(1-e*(t+e))/e:e>0?(Math.exp(e*t)-1)/e+e:t}function softExponentialPrime(t,e){return e<0?1/(1-e*(e+t)):Math.exp(e*t)}const ACTIVATION_FUNCTIONS={tanh:{activation:Math.tanh,derivate:t=>1-t*t},identity:{activation:t=>t,derivate:()=>1},logistic:{activation:logistic,derivate:t=>logistic(t)*(1-logistic(t))},arctan:{activation:Math.atan,derivate:t=>1/(t*t+1)},softsign:{activation:t=>t/(1+Math.abs(t)),derivate:t=>1/((1+Math.abs(t))*(1+Math.abs(t)))},relu:{activation:t=>t<0?0:t,derivate:t=>t<0?0:1},softplus:{activation:t=>Math.log(1+Math.exp(t)),derivate:t=>1/(1+Math.exp(-t))},bent:{activation:t=>(Math.sqrt(t*t+1)-1)/2+t,derivate:t=>t/(2*Math.sqrt(t*t+1))+1},sinusoid:{activation:Math.sin,derivate:Math.cos},sinc:{activation:t=>0===t?1:Math.sin(t)/t,derivate:t=>0===t?0:Math.cos(t)/t-Math.sin(t)/(t*t)},gaussian:{activation:t=>Math.exp(-t*t),derivate:t=>-2*t*Math.exp(-t*t)},"parametric-relu":{activation:(t,e)=>t<0?e*t:t,derivate:(t,e)=>t<0?e:1},"exponential-elu":{activation:expELU,derivate:(t,e)=>t<0?expELU(t,e)+e:1},"soft-exponential":{activation:softExponential,derivate:softExponentialPrime}};class Layer{constructor(t){this.inputSize=t.inputSize,this.outputSize=t.outputSize,this.regularization=t.regularization,this.epsilon=t.epsilon,this.activation=t.activation,this.activationParam=t.activationParam;var e=ACTIVATION_FUNCTIONS[t.activation],r=e.activation.length,n=r>1?r=>e.activation(r,t.activationParam):e.activation,i=r>1?r=>e.derivate(r,t.activationParam):e.derivate;this.activationFunction=function(t,e){this.set(t,e,n(this.get(t,e)))},this.derivate=function(t,e){this.set(t,e,i(this.get(t,e)))},t.model?(this.W=Matrix.Matrix.checkMatrix(t.W),this.b=Matrix.Matrix.checkMatrix(t.b)):(this.W=Matrix.Matrix.rand(this.inputSize,this.outputSize),this.b=Matrix.Matrix.zeros(1,this.outputSize),this.W.apply(function(e,r){this.set(e,r,this.get(e,r)/Math.sqrt(t.inputSize))}))}forward(t){var e=t.mmul(this.W).addRowVector(this.b);return e.apply(this.activationFunction),this.a=e.clone(),e}backpropagation(t,e){this.dW=e.transpose().mmul(t),this.db=Matrix.Matrix.rowVector(t.sum("column"));var r=e.clone();return t.mmul(this.W.transpose()).mul(r.apply(this.derivate))}update(){this.dW.add(this.W.clone().mul(this.regularization)),this.W.add(this.dW.mul(-this.epsilon)),this.b.add(this.db.mul(-this.epsilon))}toJSON(){return{model:"Layer",inputSize:this.inputSize,outputSize:this.outputSize,regularization:this.regularization,epsilon:this.epsilon,activation:this.activation,W:this.W,b:this.b}}static load(t){if("Layer"!==t.model)throw new RangeError("the current model is not a Layer model");return new Layer(t)}}class OutputLayer extends Layer{constructor(t){super(t),this.activationFunction=function(t,e){this.set(t,e,Math.exp(this.get(t,e)))}}static load(t){if("Layer"!==t.model)throw new RangeError("the current model is not a Layer model");return new OutputLayer(t)}}class FeedForwardNeuralNetworks{constructor(t){if((t=t||{}).model){this.hiddenLayers=t.hiddenLayers,this.iterations=t.iterations,this.learningRate=t.learningRate,this.regularization=t.regularization,this.dicts=t.dicts,this.activation=t.activation,this.activationParam=t.activationParam,this.model=new Array(t.layers.length);for(var e=0;e<this.model.length-1;++e)this.model[e]=Layer.load(t.layers[e]);this.model[this.model.length-1]=OutputLayer.load(t.layers[this.model.length-1])}else this.hiddenLayers=t.hiddenLayers||[10],this.iterations=t.iterations||50,this.learningRate=t.learningRate||.01,this.regularization=t.regularization||.01,this.activation=t.activation||"tanh",this.activationParam=t.activationParam||1,this.activation in Object.keys(ACTIVATION_FUNCTIONS)||(this.activation="tanh")}buildNetwork(t,e){var r=this.hiddenLayers.length-1+2;this.model=new Array(r),this.model[0]=new Layer({inputSize:t,outputSize:this.hiddenLayers[0],activation:this.activation,activationParam:this.activationParam,regularization:this.regularization,epsilon:this.learningRate});for(var n=1;n<this.hiddenLayers.length;++n)this.model[n]=new Layer({inputSize:this.hiddenLayers[n-1],outputSize:this.hiddenLayers[n],activation:this.activation,activationParam:this.activationParam,regularization:this.regularization,epsilon:this.learningRate});this.model[r-1]=new OutputLayer({inputSize:this.hiddenLayers[this.hiddenLayers.length-1],outputSize:e,activation:this.activation,activationParam:this.activationParam,regularization:this.regularization,epsilon:this.learningRate})}train(t,e){t=Matrix.Matrix.checkMatrix(t),this.dicts=dictOutputs(e);var r=t.columns,n=Object.keys(this.dicts.inputs).length;this.model||this.buildNetwork(r,n);for(var i=0;i<this.iterations;++i){var o=this.propagate(t);this.backpropagation(t,e,o)}}propagate(t){for(var e=t,r=0;r<this.model.length;++r)e=this.model[r].forward(e);return e.divColumnVector(e.sum("row"))}backpropagation(t,e,r){for(var n=0;n<r.rows;++n)r.set(n,this.dicts.inputs[e[n]],r.get(n,this.dicts.inputs[e[n]])-1);var i=r;for(n=this.model.length-1;n>=0;--n){var o=n>0?this.model[n-1].a:t;i=this.model[n].backpropagation(i,o)}for(n=0;n<this.model.length;++n)this.model[n].update()}predict(t){t=Matrix.Matrix.checkMatrix(t);for(var e=new Array(t.rows),r=this.propagate(t),n=0;n<t.rows;++n)e[n]=this.dicts.outputs[r.maxRowIndex(n)[1]];return e}toJSON(){for(var t={model:"FNN",hiddenLayers:this.hiddenLayers,iterations:this.iterations,learningRate:this.learningRate,regularization:this.regularization,activation:this.activation,activationParam:this.activationParam,dicts:this.dicts,layers:new Array(this.model.length)},e=0;e<this.model.length;++e)t.layers[e]=this.model[e].toJSON();return t}static load(t){if("FNN"!==t.model)throw new RangeError("the current model is not a feed forward network");return new FeedForwardNeuralNetworks(t)}}function dictOutputs(t){for(var e={},r={},n=0,i=0;i<t.length;i+=1)void 0===e[t[i]]&&(e[t[i]]=n,r[n]=t[i],n++);return{inputs:e,outputs:r}}var FeedForwardNeuralNetwork=FeedForwardNeuralNetworks;function NodeSquare(t,e,r,n){this.x=t,this.y=e,this.weights=r,this.som=n,this.neighbors={}}NodeSquare.prototype.adjustWeights=function(t,e,r){for(var n=0,i=this.weights.length;n<i;n++)this.weights[n]+=e*r*(t[n]-this.weights[n])},NodeSquare.prototype.getDistance=function(t){return Math.max(Math.abs(this.x-t.x),Math.abs(this.y-t.y))},NodeSquare.prototype.getDistanceTorus=function(t){var e=Math.abs(this.x-t.x),r=Math.abs(this.y-t.y);return Math.max(Math.min(e,this.som.gridDim.x-e),Math.min(r,this.som.gridDim.y-r))},NodeSquare.prototype.getNeighbors=function(t){if(!this.neighbors[t]){var e,r,n,i;if(this.neighbors[t]=new Array(2),this[t]>0?e=this[t]-1:this.som.torus&&(e=this.som.gridDim[t]-1),void 0!==e)"x"===t?(r=e,n=this.y):(r=this.x,n=e),this.neighbors[t][0]=this.som.nodes[r][n];this[t]<this.som.gridDim[t]-1?i=this[t]+1:this.som.torus&&(i=0),void 0!==i&&("x"===t?(r=i,n=this.y):(r=this.x,n=i),this.neighbors[t][1]=this.som.nodes[r][n])}return this.neighbors[t]},NodeSquare.prototype.getPos=function(t,e){var r,n,i=this.getNeighbors(t),o=this.som.distance;i[0]?i[1]?o(e,i[0].weights)<o(e,i[1].weights)?(r=i[0],n=-1):(r=i[1],n=1):(r=i[0],n=-1):(r=i[1],n=1);var s=1-o(e,this.weights),a=1-o(e,r.weights);return.5+.5*((s-a)/(2-s-a))*n},NodeSquare.prototype.getPosition=function(t){return[this.getPos("x",t),this.getPos("y",t)]};var nodeSquare=NodeSquare;function NodeHexagonal(t,e,r,n){nodeSquare.call(this,t,e,r,n),this.hX=t-Math.floor(e/2),this.z=0-this.hX-e}NodeHexagonal.prototype=new nodeSquare,NodeHexagonal.prototype.constructor=NodeHexagonal,NodeHexagonal.prototype.getDistance=function(t){return Math.max(Math.abs(this.hX-t.hX),Math.abs(this.y-t.y),Math.abs(this.z-t.z))},NodeHexagonal.prototype.getDistanceTorus=function(t){var e=Math.abs(this.hX-t.hX),r=Math.abs(this.y-t.y),n=Math.abs(this.z-t.z);return Math.max(Math.min(e,this.som.gridDim.x-e),Math.min(r,this.som.gridDim.y-r),Math.min(n,this.som.gridDim.z-n))},NodeHexagonal.prototype.getPosition=function(){throw new Error("Unimplemented : cannot get position of the points for hexagonal grid")};var nodeHexagonal=NodeHexagonal,defaultOptions$7={fields:3,randomizer:Math.random,distance:squareEuclidean,iterations:10,learningRate:.1,gridType:"rect",torus:!0,method:"random"};function SOM(t,e,r,n){for(var i in this.x=t,this.y=e,r=r||{},this.options={},defaultOptions$7)r.hasOwnProperty(i)?this.options[i]=r[i]:this.options[i]=defaultOptions$7[i];if("number"==typeof this.options.fields)this.numWeights=this.options.fields;else{if(!Array.isArray(this.options.fields))throw new Error("Invalid fields definition");this.numWeights=this.options.fields.length;var o=getConverters(this.options.fields);this.extractor=o.extractor,this.creator=o.creator}if("rect"===this.options.gridType)this.nodeType=nodeSquare,this.gridDim={x:t,y:e};else{this.nodeType=nodeHexagonal;var s=this.x-Math.floor(this.y/2);this.gridDim={x:s,y:this.y,z:-(0-s-this.y)}}if(this.torus=this.options.torus,this.distanceMethod=this.torus?"getDistanceTorus":"getDistance",this.distance=this.options.distance,this.maxDistance=getMaxDistance(this.distance,this.numWeights),!0!==n){if(!(t>0&&e>0))throw new Error("x and y must be positive");this.times={findBMU:0,adjust:0},this.randomizer=this.options.randomizer,this.iterationCount=0,this.iterations=this.options.iterations,this.startLearningRate=this.learningRate=this.options.learningRate,this.mapRadius=Math.floor(Math.max(t,e)/2),this.algorithmMethod=this.options.method,this._initNodes(),this.done=!1}else this.done=!0}function getConverters(t){for(var e=t.length,r=new Array(e),n=new Array(e),i=0;i<e;i++)r[i]=getNormalizer(t[i].range),n[i]=getDenormalizer(t[i].range);return{extractor:function(n){for(var i=new Array(e),o=0;o<e;o++)i[o]=r[o](n[t[o].name]);return i},creator:function(r){for(var i={},o=0;o<e;o++)i[t[o].name]=n[o](r[o]);return i}}}function getNormalizer(t){return function(e){return(e-t[0])/(t[1]-t[0])}}function getDenormalizer(t){return function(e){return t[0]+e*(t[1]-t[0])}}function squareEuclidean(t,e){for(var r=0,n=0,i=t.length;n<i;n++)r+=(t[n]-e[n])*(t[n]-e[n]);return r}function getRandomValue(t,e){return t[Math.floor(e()*t.length)]}function getMaxDistance(t,e){for(var r=new Array(e),n=new Array(e),i=0;i<e;i++)r[i]=0,n[i]=1;return t(r,n)}SOM.load=function loadModel(model,distance){if("SOM"===model.name){var x=model.data.length,y=model.data[0].length;distance?model.options.distance=distance:model.options.distance&&(model.options.distance=eval("("+model.options.distance+")"));var som=new SOM(x,y,model.options,!0);som.nodes=new Array(x);for(var i=0;i<x;i++){som.nodes[i]=new Array(y);for(var j=0;j<y;j++)som.nodes[i][j]=new som.nodeType(i,j,model.data[i][j],som)}return som}throw new Error("expecting a SOM model")},SOM.prototype.export=function(t){if(!this.done)throw new Error("model is not ready yet");var e={name:"SOM"};e.options={fields:this.options.fields,gridType:this.options.gridType,torus:this.options.torus},e.data=new Array(this.x);for(var r=0;r<this.x;r++){e.data[r]=new Array(this.y);for(var n=0;n<this.y;n++)e.data[r][n]=this.nodes[r][n].weights}return t&&(e.options.distance=this.distance.toString()),e},SOM.prototype._initNodes=function(){var t,e,r,n=Date.now();for(this.nodes=new Array(this.x),t=0;t<this.x;t++)for(this.nodes[t]=new Array(this.y),e=0;e<this.y;e++){var i=new Array(this.numWeights);for(r=0;r<this.numWeights;r++)i[r]=this.randomizer();this.nodes[t][e]=new this.nodeType(t,e,i,this)}this.times.initNodes=Date.now()-n},SOM.prototype.setTraining=function(t){if(this.trainingSet)throw new Error("training set has already been set");var e,r=Date.now(),n=t,i=t.length;if(this.extractor)for(n=new Array(i),e=0;e<i;e++)n[e]=this.extractor(t[e]);this.numIterations=this.iterations*i,"random"===this.algorithmMethod?this.timeConstant=this.numIterations/Math.log(this.mapRadius):this.timeConstant=i/Math.log(this.mapRadius),this.trainingSet=n,this.times.setTraining=Date.now()-r},SOM.prototype.trainOne=function(){return!this.done&&(this.numIterations-- >0?("random"===this.algorithmMethod?(t=this.mapRadius*Math.exp(-this.iterationCount/this.timeConstant),e=getRandomValue(this.trainingSet,this.randomizer),this._adjust(e,t),this.learningRate=this.startLearningRate*Math.exp(-this.iterationCount/this.numIterations)):(r=-Math.floor(this.iterationCount/this.trainingSet.length),t=this.mapRadius*Math.exp(r/this.timeConstant),e=this.trainingSet[this.iterationCount%this.trainingSet.length],this._adjust(e,t),(this.iterationCount+1)%this.trainingSet.length==0&&(this.learningRate=this.startLearningRate*Math.exp(r/Math.floor(this.numIterations/this.trainingSet.length)))),this.iterationCount++,!0):(this.done=!0,!1));var t,e,r},SOM.prototype._adjust=function(t,e){var r,n,i,o,s=Date.now(),a=this._findBestMatchingUnit(t),h=Date.now();this.times.findBMU+=h-s;var c=Math.floor(e),u=a.x-c,l=a.x+c,f=a.y-c,m=a.y+c;for(r=u;r<=l;r++){var g=r;for(r<0?g+=this.x:r>=this.x&&(g-=this.x),n=f;n<=m;n++){var d=n;n<0?d+=this.y:n>=this.y&&(d-=this.y),(i=a[this.distanceMethod](this.nodes[g][d]))<e&&(o=Math.exp(-i/(2*e)),this.nodes[g][d].adjustWeights(t,this.learningRate,o))}}this.times.adjust+=Date.now()-h},SOM.prototype.train=function(t){if(!this.done)for(this.setTraining(t);this.trainOne(););},SOM.prototype.getConvertedNodes=function(){for(var t=new Array(this.x),e=0;e<this.x;e++){t[e]=new Array(this.y);for(var r=0;r<this.y;r++){var n=this.nodes[e][r];t[e][r]=this.creator?this.creator(n.weights):n.weights}}return t},SOM.prototype._findBestMatchingUnit=function(t){for(var e,r,n=1/0,i=0;i<this.x;i++)for(var o=0;o<this.y;o++)(r=this.distance(this.nodes[i][o].weights,t))<n&&(n=r,e=this.nodes[i][o]);return e},SOM.prototype.predict=function(t,e){if("boolean"==typeof t&&(e=t,t=null),t||(t=this.trainingSet),Array.isArray(t)&&(Array.isArray(t[0])||"object"==typeof t[0])){var r=this;return t.map(function(t){return r._predict(t,e)})}return this._predict(t,e)},SOM.prototype._predict=function(t,e){Array.isArray(t)||(t=this.extractor(t));var r=this._findBestMatchingUnit(t),n=[r.x,r.y];return e&&(n[2]=r.getPosition(t)),n},SOM.prototype.getQuantizationError=function(){for(var t=this.getFit(),e=t.length,r=0,n=0;n<e;n++)r+=t[n];return r/e},SOM.prototype.getFit=function(t){t||(t=this.trainingSet);for(var e,r=t.length,n=new Array(r),i=0;i<r;i++)e=this._findBestMatchingUnit(t[i]),n[i]=Math.sqrt(this.distance(t[i],e.weights));return n};var src$5=SOM;function maybeToPrecision(t,e){return t<0?(t=0-t,"- ".concat("number"==typeof e?t.toPrecision(e):t.toString())):"number"==typeof e?t.toPrecision(e):t.toString()}function checkArraySize(t,e){if(!Array.isArray(t)||!Array.isArray(e))throw new TypeError("x and y must be arrays");if(t.length!==e.length)throw new RangeError("x and y arrays must have the same length")}class BaseRegression{constructor(){if(new.target===BaseRegression)throw new Error("BaseRegression must be subclassed")}predict(t){if("number"==typeof t)return this._predict(t);if(Array.isArray(t)){const e=[];for(let r=0;r<t.length;r++)e.push(this._predict(t[r]));return e}throw new TypeError("x must be a number or array")}_predict(){throw new Error("_predict must be implemented")}train(){}toString(){return""}toLaTeX(){return""}score(t,e){if(!Array.isArray(t)||!Array.isArray(e)||t.length!==e.length)throw new Error("x and y must be arrays of the same length");const r=t.length,n=new Array(r);for(let e=0;e<r;e++)n[e]=this._predict(t[e]);let i=0,o=0,s=0,a=0,h=0,c=0,u=0;for(let t=0;t<r;t++)i+=n[t],o+=e[t],h+=n[t]*n[t],c+=e[t]*e[t],u+=n[t]*e[t],0!==e[t]&&(s+=(e[t]-n[t])*(e[t]-n[t])/e[t]),a+=(e[t]-n[t])*(e[t]-n[t]);const l=(r*u-i*o)/Math.sqrt((r*h-i*i)*(r*c-o*o));return{r:l,r2:l*l,chi2:s,rmsd:Math.sqrt(a/r)}}}class PolynomialRegression extends BaseRegression{constructor(t,e,r){super(),!0===t?(this.degree=e.degree,this.powers=e.powers,this.coefficients=e.coefficients):(checkArraySize(t,e),regress(this,t,e,r))}_predict(t){let e=0;for(let r=0;r<this.powers.length;r++)e+=this.coefficients[r]*Math.pow(t,this.powers[r]);return e}toJSON(){return{name:"polynomialRegression",degree:this.degree,powers:this.powers,coefficients:this.coefficients}}toString(t){return this._toFormula(t,!1)}toLaTeX(t){return this._toFormula(t,!0)}_toFormula(t,e){let r="^",n="",i=" * ";e&&(r="^{",n="}",i="");let o="",s="";for(let e=0;e<this.coefficients.length;e++)s="",0!==this.coefficients[e]&&(s=0===this.powers[e]?maybeToPrecision(this.coefficients[e],t):1===this.powers[e]?"".concat(maybeToPrecision(this.coefficients[e],t)+i,"x"):"".concat(maybeToPrecision(this.coefficients[e],t)+i,"x").concat(r).concat(this.powers[e]).concat(n),this.coefficients[e]>0&&e!==this.coefficients.length-1?s=" + ".concat(s):e!==this.coefficients.length-1&&(s=" ".concat(s))),o=s+o;return"+"===o.charAt(0)&&(o=o.slice(1)),"f(x) = ".concat(o)}static load(t){if("polynomialRegression"!==t.name)throw new TypeError("not a polynomial regression model");return new PolynomialRegression(!0,t)}}function regress(t,e,r,n){const i=e.length;let o;if(Array.isArray(n))n=(o=n).length;else{n++,o=new Array(n);for(let t=0;t<n;t++)o[t]=t}const s=new Matrix(i,n),a=new Matrix([r]);for(let t=0;t<n;t++)for(let r=0;r<i;r++)0===o[t]?s.set(r,t,1):s.set(r,t,Math.pow(e[r],o[t]));const h=new MatrixTransposeView(s),c=h.mmul(s),u=h.mmul(new MatrixTransposeView(a));t.degree=n-1,t.powers=o,t.coefficients=solve(c,u).to1DArray()}class SimpleLinearRegression extends BaseRegression{constructor(t,e){super(),!0===t?(this.slope=e.slope,this.intercept=e.intercept,this.coefficients=[e.intercept,e.slope]):(checkArraySize(t,e),regress$1(this,t,e))}toJSON(){return{name:"simpleLinearRegression",slope:this.slope,intercept:this.intercept}}_predict(t){return this.slope*t+this.intercept}computeX(t){return(t-this.intercept)/this.slope}toString(t){let e="f(x) = ";if(0!==this.slope){const r=maybeToPrecision(this.slope,t);if(e+="".concat("1"===r?"":"".concat(r," * "),"x"),0!==this.intercept){const r=Math.abs(this.intercept),n=r===this.intercept?"+":"-";e+=" ".concat(n," ").concat(maybeToPrecision(r,t))}}else e+=maybeToPrecision(this.intercept,t);return e}toLaTeX(t){return this.toString(t)}static load(t){if("simpleLinearRegression"!==t.name)throw new TypeError("not a SLR model");return new SimpleLinearRegression(!0,t)}}function regress$1(t,e,r){const n=e.length;let i=0,o=0,s=0,a=0;for(let t=0;t<n;t++)i+=e[t],o+=r[t],s+=e[t]*e[t],a+=e[t]*r[t];const h=n*a-i*o;t.slope=h/(n*s-i*i),t.intercept=1/n*o-t.slope*(1/n)*i,t.coefficients=[t.intercept,t.slope]}class ExponentialRegression extends BaseRegression{constructor(t,e){super(),!0===t?(this.A=e.A,this.B=e.B):(checkArraySize(t,e),regress$2(this,t,e))}_predict(t){return this.B*Math.exp(t*this.A)}toJSON(){return{name:"exponentialRegression",A:this.A,B:this.B}}toString(t){return"f(x) = ".concat(maybeToPrecision(this.B,t)," * e^(").concat(maybeToPrecision(this.A,t)," * x)")}toLaTeX(t){return this.A>=0?"f(x) = ".concat(maybeToPrecision(this.B,t),"e^{").concat(maybeToPrecision(this.A,t),"x}"):"f(x) = \\frac{".concat(maybeToPrecision(this.B,t),"}{e^{").concat(maybeToPrecision(-this.A,t),"x}}")}static load(t){if("exponentialRegression"!==t.name)throw new TypeError("not a exponential regression model");return new ExponentialRegression(!0,t)}}function regress$2(t,e,r){const n=e.length,i=new Array(n);for(let t=0;t<n;t++)i[t]=Math.log(r[t]);const o=new SimpleLinearRegression(e,i);t.A=o.slope,t.B=Math.exp(o.intercept)}class PowerRegression extends BaseRegression{constructor(t,e){super(),!0===t?(this.A=e.A,this.B=e.B):(checkArraySize(t,e),regress$3(this,t,e))}_predict(t){return this.A*Math.pow(t,this.B)}toJSON(){return{name:"powerRegression",A:this.A,B:this.B}}toString(t){return"f(x) = ".concat(maybeToPrecision(this.A,t)," * x^").concat(maybeToPrecision(this.B,t))}toLaTeX(t){let e="";return e=(e=this.B>=0?"f(x) = ".concat(maybeToPrecision(this.A,t),"x^{").concat(maybeToPrecision(this.B,t),"}"):"f(x) = \\frac{".concat(maybeToPrecision(this.A,t),"}{x^{").concat(maybeToPrecision(-this.B,t),"}}")).replace(/e([+-]?[0-9]+)/g,"e^{$1}")}static load(t){if("powerRegression"!==t.name)throw new TypeError("not a power regression model");return new PowerRegression(!0,t)}}function regress$3(t,e,r){const n=e.length,i=new Array(n),o=new Array(n);for(let t=0;t<n;t++)i[t]=Math.log(e[t]),o[t]=Math.log(r[t]);const s=new SimpleLinearRegression(i,o);t.A=Math.exp(s.intercept),t.B=s.slope}class MultivariateLinearRegression{constructor(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const{intercept:n=!0,statistics:i=!0}=r;if(this.statistics=i,!0===t)this.weights=e.weights,this.inputs=e.inputs,this.outputs=e.outputs,this.intercept=e.intercept;else{t=new Matrix(t),e=new Matrix(e),n&&t.addColumn(new Array(t.rows).fill(1));let r=t.transpose();const o=r.mmul(t),s=r.mmul(e),a=new SingularValueDecomposition(o).inverse(),h=s.transpose().mmul(a).transpose();if(this.weights=h.to2DArray(),this.inputs=t.columns,this.outputs=e.columns,n&&this.inputs--,this.intercept=n,i){const r=t.mmul(h),n=e.clone().addM(r.neg()).to2DArray().map(t=>Math.pow(t[0],2)).reduce((t,e)=>t+e)/(e.rows-t.columns);this.stdError=Math.sqrt(n),this.stdErrorMatrix=pseudoInverse(o).mul(n),this.stdErrors=this.stdErrorMatrix.diagonal().map(t=>Math.sqrt(t)),this.tStats=this.weights.map((t,e)=>0===this.stdErrors[e]?0:t[0]/this.stdErrors[e])}}}predict(t){if(Array.isArray(t)){if("number"==typeof t[0])return this._predict(t);if(Array.isArray(t[0])){const e=new Array(t.length);for(let r=0;r<t.length;r++)e[r]=this._predict(t[r]);return e}}else if(Matrix.isMatrix(t)){const e=new Matrix(t.rows,this.outputs);for(let r=0;r<t.rows;r++)e.setRow(r,this._predict(t.getRow(r)));return e}throw new TypeError("x must be a matrix or array of numbers")}_predict(t){const e=new Array(this.outputs);if(this.intercept)for(let t=0;t<this.outputs;t++)e[t]=this.weights[this.inputs][t];else e.fill(0);for(let r=0;r<this.inputs;r++)for(let n=0;n<this.outputs;n++)e[n]+=this.weights[r][n]*t[r];return e}score(){throw new Error("score method is not implemented yet")}toJSON(){return{name:"multivariateLinearRegression",weights:this.weights,inputs:this.inputs,outputs:this.outputs,intercept:this.intercept,summary:this.statistics?{regressionStatistics:{standardError:this.stdError,observations:this.outputs},variables:this.weights.map((t,e)=>({label:e===this.weights.length-1?"Intercept":"X Variable ".concat(e+1),coefficients:t,standardError:this.stdErrors[e],tStat:this.tStats[e]}))}:void 0}}static load(t){if("multivariateLinearRegression"!==t.name)throw new Error("not a MLR model");return new MultivariateLinearRegression(!0,t)}}const{squaredEuclidean:squaredEuclidean$1}=euclidean$1,defaultOptions$8={sigma:1};class GaussianKernel{constructor(t){t=Object.assign({},defaultOptions$8,t),this.sigma=t.sigma,this.divisor=2*t.sigma*t.sigma}compute(t,e){const r=squaredEuclidean$1(t,e);return Math.exp(-r/this.divisor)}}var gaussianKernel=GaussianKernel;const defaultOptions$9={degree:1,constant:1,scale:1};class PolynomialKernel{constructor(t){t=Object.assign({},defaultOptions$9,t),this.degree=t.degree,this.constant=t.constant,this.scale=t.scale}compute(t,e){for(var r=0,n=0;n<t.length;n++)r+=t[n]*e[n];return Math.pow(this.scale*r+this.constant,this.degree)}}var polynomialKernel=PolynomialKernel;const defaultOptions$a={alpha:.01,constant:-Math.E};class SigmoidKernel{constructor(t){t=Object.assign({},defaultOptions$a,t),this.alpha=t.alpha,this.constant=t.constant}compute(t,e){for(var r=0,n=0;n<t.length;n++)r+=t[n]*e[n];return Math.tanh(this.alpha*r+this.constant)}}var sigmoidKernel=SigmoidKernel;const defaultOptions$b={sigma:1,degree:1};class ANOVAKernel{constructor(t){t=Object.assign({},defaultOptions$b,t),this.sigma=t.sigma,this.degree=t.degree}compute(t,e){for(var r=0,n=Math.min(t.length,e.length),i=1;i<=n;++i)r+=Math.pow(Math.exp(-this.sigma*Math.pow(Math.pow(t[i-1],i)-Math.pow(e[i-1],i),2)),this.degree);return r}}var anovaKernel=ANOVAKernel;const{squaredEuclidean:squaredEuclidean$2}=euclidean$1,defaultOptions$c={sigma:1};class CauchyKernel{constructor(t){t=Object.assign({},defaultOptions$c,t),this.sigma=t.sigma}compute(t,e){return 1/(1+squaredEuclidean$2(t,e)/(this.sigma*this.sigma))}}var cauchyKernel=CauchyKernel;const{euclidean:euclidean$2}=euclidean$1,defaultOptions$d={sigma:1};class ExponentialKernel{constructor(t){t=Object.assign({},defaultOptions$d,t),this.sigma=t.sigma,this.divisor=2*t.sigma*t.sigma}compute(t,e){const r=euclidean$2(t,e);return Math.exp(-r/this.divisor)}}var exponentialKernel=ExponentialKernel;class HistogramIntersectionKernel{compute(t,e){for(var r=Math.min(t.length,e.length),n=0,i=0;i<r;++i)n+=Math.min(t[i],e[i]);return n}}var histogramIntersectionKernel=HistogramIntersectionKernel;const{euclidean:euclidean$3}=euclidean$1,defaultOptions$e={sigma:1};class LaplacianKernel{constructor(t){t=Object.assign({},defaultOptions$e,t),this.sigma=t.sigma}compute(t,e){const r=euclidean$3(t,e);return Math.exp(-r/this.sigma)}}var laplacianKernel=LaplacianKernel;const{squaredEuclidean:squaredEuclidean$3}=euclidean$1,defaultOptions$f={constant:1};class MultiquadraticKernel{constructor(t){t=Object.assign({},defaultOptions$f,t),this.constant=t.constant}compute(t,e){return Math.sqrt(squaredEuclidean$3(t,e)+this.constant*this.constant)}}var multiquadraticKernel=MultiquadraticKernel;const{squaredEuclidean:squaredEuclidean$4}=euclidean$1,defaultOptions$g={constant:1};class RationalQuadraticKernel{constructor(t){t=Object.assign({},defaultOptions$g,t),this.constant=t.constant}compute(t,e){const r=squaredEuclidean$4(t,e);return 1-r/(r+this.constant)}}var rationalQuadraticKernel=RationalQuadraticKernel;const{Matrix:Matrix$1,MatrixTransposeView:MatrixTransposeView$1}=Matrix,kernelType={gaussian:gaussianKernel,rbf:gaussianKernel,polynomial:polynomialKernel,poly:polynomialKernel,anova:anovaKernel,cauchy:cauchyKernel,exponential:exponentialKernel,histogram:histogramIntersectionKernel,min:histogramIntersectionKernel,laplacian:laplacianKernel,multiquadratic:multiquadraticKernel,rational:rationalQuadraticKernel,sigmoid:sigmoidKernel,mlp:sigmoidKernel};class Kernel{constructor(t,e){if(this.kernelType=t,"linear"!==t)if("string"==typeof t){t=t.toLowerCase();var r=kernelType[t];if(!r)throw new Error("unsupported kernel type: ".concat(t));this.kernelFunction=new r(e)}else{if("object"!=typeof t||"function"!=typeof t.compute)throw new TypeError("first argument must be a valid kernel type or instance");this.kernelFunction=t}}compute(t,e){if(t=Matrix$1.checkMatrix(t),e=void 0===e?t:Matrix$1.checkMatrix(e),"linear"===this.kernelType)return t.mmul(new MatrixTransposeView$1(e));const r=new Matrix$1(t.rows,e.rows);if(t===e)for(let e=0;e<t.rows;e++)for(let n=e;n<t.rows;n++){const i=this.kernelFunction.compute(t.getRow(e),t.getRow(n));r.set(e,n,i),r.set(n,e,i)}else for(let n=0;n<t.rows;n++)for(let i=0;i<e.rows;i++)r.set(n,i,this.kernelFunction.compute(t.getRow(n),e.getRow(i)));return r}}var kernel=Kernel;class TheilSenRegression extends BaseRegression{constructor(t,e){super(),!0===t?(this.slope=e.slope,this.intercept=e.intercept,this.coefficients=e.coefficients):(checkArraySize(t,e),theilSen(this,t,e))}toJSON(){return{name:"TheilSenRegression",slope:this.slope,intercept:this.intercept}}_predict(t){return this.slope*t+this.intercept}computeX(t){return(t-this.intercept)/this.slope}toString(t){var e="f(x) = ";if(this.slope){var r=maybeToPrecision(this.slope,t);if(e+="".concat(Math.abs(r-1)<1e-5?"":"".concat(r," * "),"x"),this.intercept){var n=Math.abs(this.intercept),i=n===this.intercept?"+":"-";e+=" ".concat(i," ").concat(maybeToPrecision(n,t))}}else e+=maybeToPrecision(this.intercept,t);return e}toLaTeX(t){return this.toString(t)}static load(t){if("TheilSenRegression"!==t.name)throw new TypeError("not a Theil-Sen model");return new TheilSenRegression(!0,t)}}function theilSen(t,e,r){let n=e.length,i=new Array(n*n),o=0;for(let t=0;t<n;++t)for(let s=t+1;s<n;++s)e[t]!==e[s]&&(i[o++]=(r[s]-r[t])/(e[s]-e[t]));i.length=o;let s=median(i),a=new Array(n);for(let t=0;t<n;++t)a[t]=r[t]-s*e[t];t.slope=s,t.intercept=median(a),t.coefficients=[t.intercept,t.slope]}class RobustPolynomialRegression extends BaseRegression{constructor(t,e,r){super(),!0===t?(this.degree=e.degree,this.powers=e.powers,this.coefficients=e.coefficients):(checkArraySize(t,e),robustPolynomial(this,t,e,r))}toJSON(){return{name:"robustPolynomialRegression",degree:this.degree,powers:this.powers,coefficients:this.coefficients}}_predict(t){return predict(t,this.powers,this.coefficients)}toString(t){return this._toFormula(t,!1)}toLaTeX(t){return this._toFormula(t,!0)}_toFormula(t,e){let r="^",n="",i=" * ";e&&(r="^{",n="}",i="");let o="",s="";for(let e=0;e<this.coefficients.length;e++)s="",0!==this.coefficients[e]&&(s=0===this.powers[e]?maybeToPrecision(this.coefficients[e],t):1===this.powers[e]?"".concat(maybeToPrecision(this.coefficients[e],t)+i,"x"):"".concat(maybeToPrecision(this.coefficients[e],t)+i,"x").concat(r).concat(this.powers[e]).concat(n),this.coefficients[e]>0&&e!==this.coefficients.length-1?s=" + ".concat(s):e!==this.coefficients.length-1&&(s=" ".concat(s))),o=s+o;return"+"===o.charAt(0)&&(o=o.slice(1)),"f(x) = ".concat(o)}static load(t){if("robustPolynomialRegression"!==t.name)throw new TypeError("not a RobustPolynomialRegression model");return new RobustPolynomialRegression(!0,t)}}function robustPolynomial(t,e,r,n){let i=Array(n).fill(0).map((t,e)=>e);const o=getRandomTuples(e,r,n);for(var s,a=0;a<o.length;a++){for(var h=calcCoefficients(o[a],i),c=e.slice(),u=0;u<e.length;u++)c[u]=r[u]-predict(e[u],i,h),c[u]={residual:c[u]*c[u],coefficients:h};var l=residualsMedian(c);(!s||l.residual<s.residual)&&(s=l)}t.degree=n,t.powers=i,t.coefficients=s.coefficients}function getRandomTuples(t,e,r){for(var n=Math.floor(t.length/r),i=new Array(n),o=0;o<t.length;o++){for(var s=Math.floor(Math.random()*n),a=0;a<t.length;){if(!i[s]){i[s]=[{x:t[o],y:e[o]}];break}if(i[s].length<r){i[s].push({x:t[o],y:e[o]});break}a++,s=(s+1)%n}if(a===t.length)return i}return i}function calcCoefficients(t,e){for(var r=t.slice(),n=t.slice(),i=0;i<r.length;i++){n[i]=[t[i].y],r[i]=new Array(e.length);for(var o=0;o<e.length;o++)r[i][o]=Math.pow(t[i].x,e[o])}return solve(r,n).to1DArray()}function predict(t,e,r){let n=0;for(let i=0;i<e.length;i++)n+=r[i]*Math.pow(t,e[i]);return n}function residualsMedian(t){t.sort((t,e)=>t.residual-e.residual);var e=t.length,r=Math.floor(e/2);return e%2==0?t[r-1]:t[r]}function errorCalculation(t,e,r){var n=0;const i=r(e);for(var o=0;o<t.x.length;o++)n+=Math.abs(t.y[o]-i(t.x[o]));return n}function gradientFunction(t,e,r,n,i){const o=r.length,s=t.x.length;for(var a=new Array(o),h=0;h<o;h++){a[h]=new Array(s);var c=r.concat();c[h]+=n;for(var u=i(c),l=0;l<s;l++)a[h][l]=e[l]-u(t.x[l])}return new Matrix(a)}function matrixFunction(t,e){const r=t.x.length;for(var n=new Array(r),i=0;i<r;i++)n[i]=[t.y[i]-e[i]];return new Matrix(n)}function step$1(t,e,r,n,i){var o=r*n*n,s=Matrix.eye(e.length,e.length,o);const a=i(e);var h=t.x.map(t=>a(t)),c=gradientFunction(t,h,e,n,i),u=matrixFunction(t,h),l=inverse(s.add(c.mmul(c.transpose())));return(e=(e=new Matrix([e])).sub(l.mmul(c).mmul(u).mul(n).transpose())).to1DArray()}function levenbergMarquardt(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},{maxIterations:n=100,gradientDifference:i=.1,damping:o=0,errorTolerance:s=.01,minValues:a,maxValues:h,initialValues:c}=r;if(o<=0)throw new Error("The damping option must be a positive number");if(!t.x||!t.y)throw new Error("The data parameter must have x and y elements");if(!Array.isArray(t.x)||t.x.length<2||!Array.isArray(t.y)||t.y.length<2)throw new Error("The data parameter elements must be an array with more than 2 points");if(t.x.length!==t.y.length)throw new Error("The data parameter elements must have the same size");var u=c||new Array(e.length).fill(1);let l=u.length;if(h=h||new Array(l).fill(Number.MAX_SAFE_INTEGER),a=a||new Array(l).fill(Number.MIN_SAFE_INTEGER),h.length!==a.length)throw new Error("minValues and maxValues must be the same size");if(!Array.isArray(u))throw new Error("initialValues must be an array");for(var f=errorCalculation(t,u,e),m=f<=s,g=0;g<n&&!m;g++){u=step$1(t,u,o,i,e);for(let t=0;t<l;t++)u[t]=Math.min(Math.max(a[t],u[t]),h[t]);if(f=errorCalculation(t,u,e),isNaN(f))break;m=f<=s}return{parameterValues:u,parameterError:f,iterations:g}}var binarySearch=function(t,e,r,n,i){var o,s;if(void 0===n)n=0;else if((n|=0)<0||n>=t.length)throw new RangeError("invalid lower bound");if(void 0===i)i=t.length-1;else if((i|=0)<n||i>=t.length)throw new RangeError("invalid upper bound");for(;n<=i;)if((s=+r(t[o=n+(i-n>>1)],e,o,t))<0)n=o+1;else{if(!(s>0))return o;i=o-1}return~n};function assertNumber(t){if("number"!=typeof t||Number.isNaN(t))throw new TypeError("Expected a number")}var ascending=(t,e)=>(assertNumber(t),assertNumber(e),t-e),descending=(t,e)=>(assertNumber(t),assertNumber(e),e-t),numSort={ascending:ascending,descending:descending},index$2=Object.freeze({default:numSort,__moduleExports:numSort,ascending:ascending,descending:descending});const largestPrime=2147483647,primeNumbers=[largestPrime,5,11,23,47,97,197,397,797,1597,3203,6421,12853,25717,51437,102877,205759,411527,823117,1646237,3292489,6584983,13169977,26339969,52679969,105359939,210719881,421439783,842879579,1685759167,433,877,1759,3527,7057,14143,28289,56591,113189,226379,452759,905551,1811107,3622219,7244441,14488931,28977863,57955739,115911563,231823147,463646329,927292699,1854585413,953,1907,3821,7643,15287,30577,61169,122347,244703,489407,978821,1957651,3915341,7830701,15661423,31322867,62645741,125291483,250582987,501165979,1002331963,2004663929,1039,2081,4177,8363,16729,33461,66923,133853,267713,535481,1070981,2141977,4283963,8567929,17135863,34271747,68543509,137087021,274174111,548348231,1096696463,31,67,137,277,557,1117,2237,4481,8963,17929,35863,71741,143483,286973,573953,1147921,2295859,4591721,9183457,18366923,36733847,73467739,146935499,293871013,587742049,1175484103,599,1201,2411,4831,9677,19373,38747,77509,155027,310081,620171,1240361,2480729,4961459,9922933,19845871,39691759,79383533,158767069,317534141,635068283,1270136683,311,631,1277,2557,5119,10243,20507,41017,82037,164089,328213,656429,1312867,2625761,5251529,10503061,21006137,42012281,84024581,168049163,336098327,672196673,1344393353,3,7,17,37,79,163,331,673,1361,2729,5471,10949,21911,43853,87719,175447,350899,701819,1403641,2807303,5614657,11229331,22458671,44917381,89834777,179669557,359339171,718678369,1437356741,43,89,179,359,719,1439,2879,5779,11579,23159,46327,92657,185323,370661,741337,1482707,2965421,5930887,11861791,23723597,47447201,94894427,189788857,379577741,759155483,1518310967,379,761,1523,3049,6101,12203,24407,48817,97649,195311,390647,781301,1562611,3125257,6250537,12501169,25002389,50004791,100009607,200019221,400038451,800076929,1600153859,13,29,59,127,257,521,1049,2099,4201,8419,16843,33703,67409,134837,269683,539389,1078787,2157587,4315183,8630387,17260781,34521589,69043189,138086407,276172823,552345671,1104691373,19,41,83,167,337,677,1361,2729,5471,10949,21911,43853,87719,175447,350899,701819,1403641,2807303,5614657,11229331,22458671,44917381,89834777,179669557,359339171,718678369,1437356741,53,107,223,449,907,1823,3659,7321,14653,29311,58631,117269,234539,469099,938207,1876417,3752839,7505681,15011389,30022781,60045577,120091177,240182359,480364727,960729461,1921458943];function nextPrime(t){let e=binarySearch(primeNumbers,t,ascending);return e<0&&(e=~e),primeNumbers[e]}primeNumbers.sort(ascending);const FREE=0,FULL=1,REMOVED=2,defaultInitialCapacity=150,defaultMinLoadFactor=1/6,defaultMaxLoadFactor=2/3;class HashTable{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(t instanceof HashTable)return this.table=t.table.slice(),this.values=t.values.slice(),this.state=t.state.slice(),this.minLoadFactor=t.minLoadFactor,this.maxLoadFactor=t.maxLoadFactor,this.distinct=t.distinct,this.freeEntries=t.freeEntries,this.lowWaterMark=t.lowWaterMark,void(this.highWaterMark=t.maxLoadFactor);const e=void 0===t.initialCapacity?defaultInitialCapacity:t.initialCapacity;if(e<0)throw new RangeError("initial capacity must not be less than zero: ".concat(e));const r=void 0===t.minLoadFactor?defaultMinLoadFactor:t.minLoadFactor,n=void 0===t.maxLoadFactor?defaultMaxLoadFactor:t.maxLoadFactor;if(r<0||r>=1)throw new RangeError("invalid minLoadFactor: ".concat(r));if(n<=0||n>=1)throw new RangeError("invalid maxLoadFactor: ".concat(n));if(r>=n)throw new RangeError("minLoadFactor (".concat(r,") must be smaller than maxLoadFactor (").concat(n,")"));let i=e;0===(i=nextPrime(i=i/n|0))&&(i=1),this.table=newArray$1(i),this.values=newArray$1(i),this.state=newArray$1(i),this.minLoadFactor=r,this.maxLoadFactor=i===largestPrime?1:n,this.distinct=0,this.freeEntries=i,this.lowWaterMark=0,this.highWaterMark=chooseHighWaterMark(i,this.maxLoadFactor)}clone(){return new HashTable(this)}get size(){return this.distinct}get(t){const e=this.indexOfKey(t);return e<0?0:this.values[e]}set(t,e){let r=this.indexOfInsertion(t);if(r<0)return r=-r-1,this.values[r]=e,!1;if(this.distinct>this.highWaterMark){const r=chooseGrowCapacity(this.distinct+1,this.minLoadFactor,this.maxLoadFactor);return this.rehash(r),this.set(t,e)}if(this.table[r]=t,this.values[r]=e,this.state[r]===FREE&&this.freeEntries--,this.state[r]=FULL,this.distinct++,this.freeEntries<1){const t=chooseGrowCapacity(this.distinct+1,this.minLoadFactor,this.maxLoadFactor);this.rehash(t)}return!0}remove(t,e){const r=this.indexOfKey(t);return!(r<0)&&(this.state[r]=REMOVED,this.distinct--,e||this.maybeShrinkCapacity(),!0)}delete(t,e){const r=this.indexOfKey(t);return!(r<0)&&(this.state[r]=FREE,this.distinct--,e||this.maybeShrinkCapacity(),!0)}maybeShrinkCapacity(){if(this.distinct<this.lowWaterMark){const t=chooseShrinkCapacity(this.distinct,this.minLoadFactor,this.maxLoadFactor);this.rehash(t)}}containsKey(t){return this.indexOfKey(t)>=0}indexOfKey(t){const e=this.table,r=this.state,n=this.table.length,i=2147483647&t;let o=i%n,s=i%(n-2);for(0===s&&(s=1);r[o]!==FREE&&(r[o]===REMOVED||e[o]!==t);)(o-=s)<0&&(o+=n);return r[o]===FREE?-1:o}containsValue(t){return this.indexOfValue(t)>=0}indexOfValue(t){const e=this.values,r=this.state;for(var n=0;n<r.length;n++)if(r[n]===FULL&&e[n]===t)return n;return-1}indexOfInsertion(t){const e=this.table,r=this.state,n=e.length,i=2147483647&t;let o=i%n,s=i%(n-2);for(0===s&&(s=1);r[o]===FULL&&e[o]!==t;)(o-=s)<0&&(o+=n);if(r[o]===REMOVED){const i=o;for(;r[o]!==FREE&&(r[o]===REMOVED||e[o]!==t);)(o-=s)<0&&(o+=n);r[o]===FREE&&(o=i)}return r[o]===FULL?-o-1:o}ensureCapacity(t){if(this.table.length<t){const e=nextPrime(t);this.rehash(e)}}rehash(t){const e=this.table.length;if(t<=this.distinct)throw new Error("Unexpected");const r=this.table,n=this.values,i=this.state,o=newArray$1(t),s=newArray$1(t),a=newArray$1(t);this.lowWaterMark=chooseLowWaterMark(t,this.minLoadFactor),this.highWaterMark=chooseHighWaterMark(t,this.maxLoadFactor),this.table=o,this.values=s,this.state=a,this.freeEntries=t-this.distinct;for(var h=0;h<e;h++)if(i[h]===FULL){var c=r[h],u=this.indexOfInsertion(c);o[u]=c,s[u]=n[h],a[u]=FULL}}forEachKey(t){for(var e=0;e<this.state.length;e++)if(this.state[e]===FULL&&!t(this.table[e]))return!1;return!0}forEachValue(t){for(var e=0;e<this.state.length;e++)if(this.state[e]===FULL&&!t(this.values[e]))return!1;return!0}forEachPair(t){for(var e=0;e<this.state.length;e++)if(this.state[e]===FULL&&!t(this.table[e],this.values[e]))return!1;return!0}}function chooseLowWaterMark(t,e){return t*e|0}function chooseHighWaterMark(t,e){return Math.min(t-2,t*e|0)}function chooseGrowCapacity(t,e,r){return nextPrime(Math.max(t+1,4*t/(3*e+r)|0))}function chooseShrinkCapacity(t,e,r){return nextPrime(Math.max(t+1,4*t/(e+3*r)|0))}function newArray$1(t){return Array(t).fill(0)}class SparseMatrix{constructor(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(t instanceof SparseMatrix){const e=t;this._init(e.rows,e.columns,e.elements.clone(),e.threshold)}else if(Array.isArray(t)){const s=t;t=s.length,r=e||{},e=s[0].length,this._init(t,e,new HashTable(r),r.threshold);for(var n=0;n<t;n++)for(var i=0;i<e;i++){var o=s[n][i];this.threshold&&Math.abs(o)<this.threshold&&(o=0),0!==o&&this.elements.set(n*e+i,s[n][i])}}else this._init(t,e,new HashTable(r),r.threshold)}_init(t,e,r,n){this.rows=t,this.columns=e,this.elements=r,this.threshold=n||0}static eye(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:t;const r=Math.min(t,e),n=new SparseMatrix(t,e,{initialCapacity:r});for(var i=0;i<r;i++)n.set(i,i,1);return n}clone(){return new SparseMatrix(this)}to2DArray(){const t=new Array(this.rows);for(var e=0;e<this.rows;e++){t[e]=new Array(this.columns);for(var r=0;r<this.columns;r++)t[e][r]=this.get(e,r)}return t}isSquare(){return this.rows===this.columns}isSymmetric(){if(!this.isSquare())return!1;var t=!0;return this.forEachNonZero((e,r,n)=>this.get(r,e)!==n?(t=!1,!1):n),t}bandWidth(){let t=this.columns,e=-1;return this.forEachNonZero((r,n,i)=>{let o=r-n;return t=Math.min(t,o),e=Math.max(e,o),i}),e-t}isBanded(t){return this.bandWidth()<=t}get cardinality(){return this.elements.size}get size(){return this.rows*this.columns}get(t,e){return this.elements.get(t*this.columns+e)}set(t,e,r){return this.threshold&&Math.abs(r)<this.threshold&&(r=0),0===r?this.elements.remove(t*this.columns+e):this.elements.set(t*this.columns+e,r),this}mmul(t){this.columns!==t.rows&&console.warn("Number of columns of left matrix are not equal to number of rows of right matrix.");const e=this.rows,r=t.columns,n=new SparseMatrix(e,r);return this.forEachNonZero((e,r,i)=>(t.forEachNonZero((t,o,s)=>(r===t&&n.set(e,o,n.get(e,o)+i*s),s)),i)),n}kroneckerProduct(t){const e=this.rows,r=this.columns,n=t.rows,i=t.columns,o=new SparseMatrix(e*n,r*i,{initialCapacity:this.cardinality*t.cardinality});return this.forEachNonZero((e,r,s)=>(t.forEachNonZero((t,a,h)=>(o.set(n*e+t,i*r+a,s*h),h)),s)),o}forEachNonZero(t){return this.elements.forEachPair((e,r)=>{const n=e/this.columns|0,i=e%this.columns;let o=t(n,i,r);return!1!==o&&(this.threshold&&Math.abs(o)<this.threshold&&(o=0),o!==r&&(0===o?this.elements.remove(e,!0):this.elements.set(e,o)),!0)}),this.elements.maybeShrinkCapacity(),this}getNonZeros(){const t=this.cardinality,e=new Array(t),r=new Array(t),n=new Array(t);var i=0;return this.forEachNonZero((t,o,s)=>(e[i]=t,r[i]=o,n[i]=s,i++,s)),{rows:e,columns:r,values:n}}setThreshold(t){return 0!==t&&t!==this.threshold&&(this.threshold=t,this.forEachNonZero((t,e,r)=>r)),this}transpose(){let t=new SparseMatrix(this.columns,this.rows,{initialCapacity:this.cardinality});return this.forEachNonZero((e,r,n)=>(t.set(r,e,n),n)),t}}SparseMatrix.prototype.klass="Matrix",SparseMatrix.identity=SparseMatrix.eye,SparseMatrix.prototype.tensorProduct=SparseMatrix.prototype.kroneckerProduct;var inplaceOperator="\n(function %name%(value) {\n    if (typeof value === 'number') return this.%name%S(value);\n    return this.%name%M(value);\n})\n",inplaceOperatorScalar="\n(function %name%S(value) {\n    this.forEachNonZero((i, j, v) => v %op% value);\n    return this;\n})\n",inplaceOperatorMatrix="\n(function %name%M(matrix) {\n    matrix.forEachNonZero((i, j, v) => {\n        this.set(i, j, this.get(i, j) %op% v);\n        return v;\n    });\n    return this;\n})\n",staticOperator="\n(function %name%(matrix, value) {\n    var newMatrix = new SparseMatrix(matrix);\n    return newMatrix.%name%(value);\n})\n",inplaceMethod="\n(function %name%() {\n    this.forEachNonZero((i, j, v) => %method%(v));\n    return this;\n})\n",staticMethod="\n(function %name%(matrix) {\n    var newMatrix = new SparseMatrix(matrix);\n    return newMatrix.%name%();\n})\n";const operators=[["+","add"],["-","sub","subtract"],["*","mul","multiply"],["/","div","divide"],["%","mod","modulus"],["&","and"],["|","or"],["^","xor"],["<<","leftShift"],[">>","signPropagatingRightShift"],[">>>","rightShift","zeroFillRightShift"]];for(const operator of operators)for(let i=1;i<operator.length;i++)SparseMatrix.prototype[operator[i]]=eval(fillTemplateFunction(inplaceOperator,{name:operator[i],op:operator[0]})),SparseMatrix.prototype["".concat(operator[i],"S")]=eval(fillTemplateFunction(inplaceOperatorScalar,{name:"".concat(operator[i],"S"),op:operator[0]})),SparseMatrix.prototype["".concat(operator[i],"M")]=eval(fillTemplateFunction(inplaceOperatorMatrix,{name:"".concat(operator[i],"M"),op:operator[0]})),SparseMatrix[operator[i]]=eval(fillTemplateFunction(staticOperator,{name:operator[i]}));var methods=[["~","not"]];["abs","acos","acosh","asin","asinh","atan","atanh","cbrt","ceil","clz32","cos","cosh","exp","expm1","floor","fround","log","log1p","log10","log2","round","sign","sin","sinh","sqrt","tan","tanh","trunc"].forEach(function(t){methods.push(["Math.".concat(t),t])});for(const method of methods)for(let i=1;i<method.length;i++)SparseMatrix.prototype[method[i]]=eval(fillTemplateFunction(inplaceMethod,{name:method[i],method:method[0]})),SparseMatrix[method[i]]=eval(fillTemplateFunction(staticMethod,{name:method[i]}));function fillTemplateFunction(t,e){for(const r in e)t=t.replace(new RegExp("%".concat(r,"%"),"g"),e[r]);return t}function additiveSymmetric(t,e){for(var r=0,n=t.length,i=0;r<n;r++)i+=(t[r]-e[r])*(t[r]-e[r])*(t[r]+e[r])/(t[r]*e[r]);return 2*i}function avg(t,e){for(var r=t.length,n=0,i=0,o=0,s=0;s<r;s++)i+=o=Math.abs(t[s]-e[s]),n<o&&(n=o);return(n+i)/2}function bhattacharyya(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=Math.sqrt(t[i]*e[i]);return-Math.log(n)}function canberra(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=Math.abs(t[i]-e[i])/(t[i]+e[i]);return n}function chebyshev(t,e){for(var r=t.length,n=0,i=0,o=0;o<r;o++)n<(i=Math.abs(t[o]-e[o]))&&(n=i);return n}function clark(t,e){for(var r=0,n=t.length,i=0;r<n;r++)i+=Math.sqrt((t[r]-e[r])*(t[r]-e[r])/((t[r]+e[r])*(t[r]+e[r])));return 2*i}function czekanowskiSimilarity(t,e){for(var r=0,n=0,i=0;i<t.length;i++)r+=Math.min(t[i],e[i]),n+=t[i]+e[i];return 2*r/n}function czekanowskiDistance(t,e){return 1-czekanowskiSimilarity(t,e)}function dice(t,e){for(var r=t.length,n=0,i=0,o=0,s=0;s<r;s++)n+=t[s]*t[s],i+=e[s]*e[s],o+=(t[s]-e[s])*(t[s]-e[s]);return o/(n+i)}function divergence(t,e){for(var r=0,n=t.length,i=0;r<n;r++)i+=(t[r]-e[r])*(t[r]-e[r])/((t[r]+e[r])*(t[r]+e[r]));return 2*i}function fidelity(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=Math.sqrt(t[i]*e[i]);return n}function gower(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=Math.abs(t[i]-e[i]);return n/r}function harmonicMean(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=t[i]*e[i]/(t[i]+e[i]);return 2*n}function hellinger(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=Math.sqrt(t[i]*e[i]);return 2*Math.sqrt(1-n)}function innerProduct(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=t[i]*e[i];return n}function intersection(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=Math.min(t[i],e[i]);return 1-n}function jaccard(t,e){for(var r=t.length,n=0,i=0,o=0,s=0,a=0;a<r;a++)n+=t[a]*e[a],i+=t[a]*t[a],o+=e[a]*e[a],s+=(t[a]-e[a])*(t[a]-e[a]);return s/(i+o-n)}function jeffreys(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=(t[i]-e[i])*Math.log(t[i]/e[i]);return n}function jensenDifference(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=(t[i]*Math.log(t[i])+e[i]*Math.log(e[i]))/2-(t[i]+e[i])/2*Math.log((t[i]+e[i])/2);return n}function jensenShannon(t,e){for(var r=t.length,n=0,i=0,o=0;o<r;o++)n+=t[o]*Math.log(2*t[o]/(t[o]+e[o])),i+=e[o]*Math.log(2*e[o]/(t[o]+e[o]));return(n+i)/2}function kdivergence(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=t[i]*Math.log(2*t[i]/(t[i]+e[i]));return n}function kulczynski(t,e){for(var r=t.length,n=0,i=0,o=0;o<r;o++)n+=Math.abs(t[o]-e[o]),i+=Math.min(t[o],e[o]);return n/i}function kullbackLeibler(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=t[i]*Math.log(t[i]/e[i]);return n}function kumarHassebrook(t,e){for(var r=t.length,n=0,i=0,o=0,s=0;s<r;s++)n+=t[s]*e[s],i+=t[s]*t[s],o+=e[s]*e[s];return n/(i+o-n)}function kumarJohnson(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=Math.pow(t[i]*t[i]-e[i]*e[i],2)/(2*Math.pow(t[i]*e[i],1.5));return n}function lorentzian(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=Math.log(Math.abs(t[i]-e[i])+1);return n}function manhattan(t,e){for(var r=0,n=t.length,i=0;r<n;r++)i+=Math.abs(t[r]-e[r]);return i}function matusita(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=Math.sqrt(t[i]*e[i]);return Math.sqrt(2-2*n)}function minkowski(t,e,r){for(var n=0,i=t.length,o=0;n<i;n++)o+=Math.pow(Math.abs(t[n]-e[n]),r);return Math.pow(o,1/r)}function motyka(t,e){for(var r=t.length,n=0,i=0,o=0;o<r;o++)n+=Math.min(t[o],e[o]),i+=t[o]+e[o];return 1-n/i}function neyman(t,e){for(var r=0,n=t.length,i=0;r<n;r++)i+=(t[r]-e[r])*(t[r]-e[r])/t[r];return i}function pearson(t,e){for(var r=0,n=t.length,i=0;r<n;r++)i+=(t[r]-e[r])*(t[r]-e[r])/e[r];return i}function probabilisticSymmetric(t,e){for(var r=0,n=t.length,i=0;r<n;r++)i+=(t[r]-e[r])*(t[r]-e[r])/(t[r]+e[r]);return 2*i}function ruzicka(t,e){for(var r=t.length,n=0,i=0,o=0;o<r;o++)n+=Math.min(t[o],e[o]),i+=Math.max(t[o],e[o]);return n/i}function soergel(t,e){for(var r=t.length,n=0,i=0,o=0;o<r;o++)n+=Math.abs(t[o]-e[o]),i+=Math.max(t[o],e[o]);return n/i}function sorensen(t,e){for(var r=t.length,n=0,i=0,o=0;o<r;o++)n+=Math.abs(t[o]-e[o]),i+=t[o]+e[o];return n/i}function squared(t,e){for(var r=0,n=t.length,i=0;r<n;r++)i+=(t[r]-e[r])*(t[r]-e[r])/(t[r]+e[r]);return i}function squaredChord(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=(Math.sqrt(t[i])-Math.sqrt(e[i]))*(Math.sqrt(t[i])-Math.sqrt(e[i]));return n}function taneja(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=(t[i]+e[i])/2*Math.log((t[i]+e[i])/(2*Math.sqrt(t[i]*e[i])));return n}function tanimoto(t,e,r){if(r){for(var n=0,i=0,o=0;o<t.length;o++)n+=t[o]&&e[o],i+=t[o]||e[o];return 0===i?1:n/i}for(var s=t.length,a=0,h=0,c=0,u=0;u<s;u++)a+=t[u],h+=e[u],c+=Math.min(t[u],e[u]);return 1-(a+h-2*c)/(a+h-c)}function tanimoto$1(t,e,r){if(r)return 1-tanimoto(t,e,r);for(var n=t.length,i=0,o=0,s=0,a=0;a<n;a++)i+=t[a],o+=e[a],s+=Math.min(t[a],e[a]);return(i+o-2*s)/(i+o-s)}function topsoe(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=t[i]*Math.log(2*t[i]/(t[i]+e[i]))+e[i]*Math.log(2*e[i]/(t[i]+e[i]));return n}function waveHedges(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=1-Math.min(t[i],e[i])/Math.max(t[i],e[i]);return n}var distances=Object.freeze({euclidean:euclidean,squaredEuclidean:squaredEuclidean,additiveSymmetric:additiveSymmetric,avg:avg,bhattacharyya:bhattacharyya,canberra:canberra,chebyshev:chebyshev,clark:clark,czekanowski:czekanowskiDistance,dice:dice,divergence:divergence,fidelity:fidelity,gower:gower,harmonicMean:harmonicMean,hellinger:hellinger,innerProduct:innerProduct,intersection:intersection,jaccard:jaccard,jeffreys:jeffreys,jensenDifference:jensenDifference,jensenShannon:jensenShannon,kdivergence:kdivergence,kulczynski:kulczynski,kullbackLeibler:kullbackLeibler,kumarHassebrook:kumarHassebrook,kumarJohnson:kumarJohnson,lorentzian:lorentzian,manhattan:manhattan,matusita:matusita,minkowski:minkowski,motyka:motyka,neyman:neyman,pearson:pearson,probabilisticSymmetric:probabilisticSymmetric,ruzicka:ruzicka,soergel:soergel,sorensen:sorensen,squared:squared,squaredChord:squaredChord,taneja:taneja,tanimoto:tanimoto$1,topsoe:topsoe,waveHedges:waveHedges});function createTree(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};var r=t[0];const{minWindow:n=.16,threshold:i=.01,from:o=r[0],to:s=r[r.length-1]}=e;return mainCreateTree(t[0],t[1],o,s,n,i)}function mainCreateTree(t,e,r,n,i,o){if(n-r<i)return null;var s=binarySearch(t,r,ascending);s<0&&(s=~s);for(var a=0,h=0,c=s;c<t.length&&!(t[c]>=n);c++)a+=e[c],h+=t[c]*e[c];return a<o?null:(h/=a)-r<1e-6||n-h<1e-6?null:h-r<i/4?mainCreateTree(t,e,h,n,i,o):n-h<i/4?mainCreateTree(t,e,r,h,i,o):new Tree(a,h,mainCreateTree(t,e,r,h,i,o),mainCreateTree(t,e,h,n,i,o))}class Tree{constructor(t,e,r,n){this.sum=t,this.center=e,this.left=r,this.right=n}}function getSimilarity(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const{alpha:n=.1,beta:i=.33,gamma:o=.001}=r;return null===t||null===e?0:(Array.isArray(t)&&(t=createTree(t)),Array.isArray(e)&&(e=createTree(e)),i*(n*Math.min(t.sum,e.sum)/Math.max(t.sum,e.sum)+(1-n)*Math.exp(-o*Math.abs(t.center-e.center)))+(1-i)*(getSimilarity(t.left,e.left,r)+getSimilarity(t.right,e.right,r))/2)}function treeSimilarity(t,e){return getSimilarity(t,e,arguments.length>2&&void 0!==arguments[2]?arguments[2]:{})}function getFunction(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return(e,r)=>getSimilarity(e,r,t)}var index$3=Object.freeze({treeSimilarity:treeSimilarity,getFunction:getFunction,createTree:createTree});function cosine(t,e){for(var r=t.length,n=0,i=0,o=0,s=0;s<r;s++)n+=t[s]*e[s],i+=t[s]*t[s],o+=e[s]*e[s];return n/(Math.sqrt(i)*Math.sqrt(o))}function dice$1(t,e){return 1-dice(t,e)}function intersection$1(t,e){return 1-intersection(t,e)}function jaccard$1(t,e){return 1-jaccard(t,e)}function kulczynski$1(t,e){return 1/kulczynski(t,e)}function motyka$1(t,e){return 1-motyka(t,e)}function pearson$1(t,e){for(var r=mean(t),n=mean(e),i=new Array(t.length),o=new Array(e.length),s=0;s<i.length;s++)i[s]=t[s]-r,o[s]=e[s]-n;return cosine(i,o)}function squaredChord$1(t,e){return 1-squaredChord(t,e)}var similarities=Object.freeze({tree:index$3,cosine:cosine,czekanowski:czekanowskiSimilarity,dice:dice$1,intersection:intersection$1,jaccard:jaccard$1,kulczynski:kulczynski$1,motyka:motyka$1,pearson:pearson$1,squaredChord:squaredChord$1,tanimoto:tanimoto}),acc=t=>{const e=t.cutoffs.length,r=new Array(e);for(var n=0;n<e;n++)r[n]=(t.tn[n]+t.tp[n])/(e-1);return r},err=t=>{const e=t.cutoffs.length,r=new Array(e);for(var n=0;n<e;n++)r[n]=t.fn[n]+t.fp[n]/(e-1);return r},fpr=t=>{const e=t.cutoffs.length,r=new Array(e);for(var n=0;n<e;n++)r[n]=t.fp[n]/t.nNeg;return r},tpr=t=>{const e=t.cutoffs.length,r=new Array(e);for(var n=0;n<e;n++)r[n]=t.tp[n]/t.nPos;return r},fnr=t=>{const e=t.cutoffs.length,r=new Array(e);for(var n=0;n<e;n++)r[n]=t.fn[n]/t.nPos;return r},tnr=t=>{const e=t.cutoffs.length,r=new Array(e);for(var n=0;n<e;n++)r[n]=t.tn[n]/t.nNeg;return r},ppv=t=>{const e=t.cutoffs.length,r=new Array(e);for(var n=0;n<e;n++)r[n]=t.fp[n]+t.tp[n]!==0?t.tp[n]/(t.fp[n]+t.tp[n]):0;return r},npv=t=>{const e=t.cutoffs.length,r=new Array(e);for(var n=0;n<e;n++)r[n]=t.fn[n]+t.tn[n]!==0?t.tn[n]/(t.fn[n]+t.tn[n]):0;return r},pcfall=t=>{const e=t.cutoffs.length,r=new Array(e);for(var n=0;n<e;n++)r[n]=t.fp[n]+t.tp[n]!==0?1-t.tp[n]/(t.fp[n]+t.tp[n]):1;return r},pcmiss=t=>{const e=t.cutoffs.length,r=new Array(e);for(var n=0;n<e;n++)r[n]=t.fn[n]+t.tn[n]!==0?1-t.tn[n]/(t.fn[n]+t.tn[n]):1;return r},lift=t=>{const e=t.cutoffs.length,r=new Array(e);for(var n=0;n<e;n++)r[n]=0!==t.nPosPred[n]?t.tp[n]/t.nPos/(t.nPosPred[n]/t.nSamples):0;return r},rpp=t=>{const e=t.cutoffs.length,r=new Array(e);for(var n=0;n<e;n++)r[n]=t.nPosPred[n]/t.nSamples;return r},rnp=t=>{const e=t.cutoffs.length,r=new Array(e);for(var n=0;n<e;n++)r[n]=t.nNegPred[n]/t.nSamples;return r},threshold=t=>{const e=t.cutoffs.slice();return e[0]=e[1],e},measures={acc:acc,err:err,fpr:fpr,tpr:tpr,fnr:fnr,tnr:tnr,ppv:ppv,npv:npv,pcfall:pcfall,pcmiss:pcmiss,lift:lift,rpp:rpp,rnp:rnp,threshold:threshold};class Performance{constructor(t,e,r){if(r=r||{},t.length!==e.length||t[0].length!==e[0].length)throw new Error("dimensions of prediction and target do not match");const n=t.length,i=t[0].length,o=!r.max,s=[];if(r.all)for(var a=0;a<n;a++)for(var h=0;h<i;h++)s.push({pred:t[a][h],targ:e[a][h]});else{if(n<3||n!==i)throw new Error('When "all" option is false, the prediction matrix must be square and have at least 3 columns');for(a=0;a<n-1;a++)for(h=a+1;h<i;h++)s.push({pred:t[a][h],targ:e[a][h]})}o?s.sort((t,e)=>t.pred-e.pred):s.sort((t,e)=>e.pred-t.pred);const c=this.cutoffs=[o?Number.MIN_VALUE:Number.MAX_VALUE],u=this.fp=[0],l=this.tp=[0];var f=0,m=0,g=s[0].pred,d=0,p=0;for(a=0;a<s.length;a++)s[a].pred!==g&&(c.push(g),u.push(p),l.push(d),g=s[a].pred),s[a].targ?(f++,d++):(m++,p++);c.push(g),u.push(p),l.push(d);const w=c.length,v=this.fn=new Array(w),x=this.tn=new Array(w),y=this.nPosPred=new Array(w),M=this.nNegPred=new Array(w);for(a=0;a<w;a++)v[a]=f-l[a],x[a]=m-u[a],y[a]=l[a]+u[a],M[a]=x[a]+v[a];this.nPos=f,this.nNeg=m,this.nSamples=f+m}getMeasure(t){if("string"!=typeof t)throw new Error("No measure specified");if(!measures[t])throw new Error("The specified measure (".concat(t,") does not exist"));return measures[t](this)}getAURC(){const t=this.cutoffs.length,e=new Array(t),r=new Array(t);for(var n=0;n<t;n++)e[n]=this.fp[n]/this.nNeg,r[n]=this.tp[n]/this.nPos;var i=0;for(n=1;n<t;n++)i+=.5*(e[n]-e[n-1])*(r[n]+r[n-1]);return i}getAUDC(){const t=this.cutoffs.length,e=new Array(t),r=new Array(t);for(var n=0;n<t;n++)e[n]=this.fn[n]/this.nPos,r[n]=this.fp[n]/this.nNeg;var i=0;for(n=1;n<t;n++)i+=.5*(e[n]+e[n-1])*(r[n]-r[n-1]);return i}getDistribution(t){t=t||{};for(var e=this.cutoffs.length,r=t.xMin||Math.floor(100*this.cutoffs[e-1])/100,n=t.xMax||Math.ceil(100*this.cutoffs[1])/100,i=t.interval||Math.floor((n-r)/20*1e7-1)/1e7,o=[],s=[],a=[],h=[],c=[],u=this.tp[e-1],l=0,f=this.fp[e-1],m=0,g=r,d=e-1;g<=n;g+=i){for(;this.cutoffs[d]<g;)d--;o.push(g);var p=u-l-this.tp[d],w=f-m-this.fp[d];l+=p,m+=w,s.push(w),a.push(p),h.push(100-(f-this.fp[d])/f*100),c.push(100-(u-this.tp[d])/u*100)}return{xLabels:o,interValues:s,intraValues:a,interCumPercent:h,intraCumPercent:c}}}Performance.names={acc:"Accuracy",err:"Error rate",fpr:"False positive rate",tpr:"True positive rate",fnr:"False negative rate",tnr:"True negative rate",ppv:"Positive predictive value",npv:"Negative predictive value",pcfall:"Prediction-conditioned fallout",pcmiss:"Prediction-conditioned miss",lift:"Lift value",rpp:"Rate of positive predictions",rnp:"Rate of negative predictions",threshold:"Threshold"};var src$6=Performance,defaultOptions$h={size:1,value:0};function arrayCase(t,e){var r=t.length;"number"==typeof e.size&&(e.size=[e.size,e.size]);var n,i,o=r+e.size[0]+e.size[1];if(e.output){if(e.output.length!==o)throw new RangeError("Wrong output size");n=e.output}else n=new Array(o);if("circular"===e.value)for(i=0;i<o;i++)i<e.size[0]?n[i]=t[(r-e.size[0]%r+i)%r]:i<e.size[0]+r?n[i]=t[i-e.size[0]]:n[i]=t[(i-e.size[0])%r];else if("replicate"===e.value)for(i=0;i<o;i++)i<e.size[0]?n[i]=t[0]:i<e.size[0]+r?n[i]=t[i-e.size[0]]:n[i]=t[r-1];else if("symmetric"===e.value){if(e.size[0]>r||e.size[1]>r)throw new RangeError("expanded value should not be bigger than the data length");for(i=0;i<o;i++)i<e.size[0]?n[i]=t[e.size[0]-1-i]:i<e.size[0]+r?n[i]=t[i-e.size[0]]:n[i]=t[2*r+e.size[0]-i-1]}else for(i=0;i<o;i++)i<e.size[0]?n[i]=e.value:i<e.size[0]+r?n[i]=t[i-e.size[0]]:n[i]=e.value;return n}function matrixCase(t,e){throw void 0===e.size[0]&&(e.size=[e.size,e.size,e.size,e.size]),new Error("matrix not supported yet, sorry")}function padArray(t,e){if(e=Object.assign({},defaultOptions$h,e),Array.isArray(t))return Array.isArray(t[0])?matrixCase(t,e):arrayCase(t,e);throw new TypeError("data should be an array")}var src$7=padArray;const{Matrix:Matrix$2,MatrixTransposeView:MatrixTransposeView$2,inverse:inverse$1}=Matrix,defaultOptions$i={windowSize:5,derivative:1,polynomial:2,pad:"none",padValue:"replicate"};function SavitzkyGolay(t,e,r){if((r=Object.assign({},defaultOptions$i,r)).windowSize%2==0||r.windowSize<5||!Number.isInteger(r.windowSize))throw new RangeError("Invalid window size (should be odd and at least 5 integer number)");if(r.derivative<0||!Number.isInteger(r.derivative))throw new RangeError("Derivative should be a positive integer");if(r.polynomial<1||!Number.isInteger(r.polynomial))throw new RangeError("Polynomial should be a positive integer");var n,i,o=Math.floor(r.windowSize/2);"pre"===r.pad&&(t=src$7(t,{size:o,value:r.padValue}));var s=new Array(t.length-2*o);if(5!==r.windowSize||2!==r.polynomial||1!==r.derivative&&2!==r.derivative){for(var a=Matrix$2.ones(r.windowSize,r.polynomial+1),h=-(r.windowSize-1)/2,c=0;c<a.rows;c++)for(var u=0;u<a.columns;u++)h+1===0&&0===u||a.set(c,u,Math.pow(h+c,u));var l=new MatrixTransposeView$2(a);n=(n=inverse$1(l.mmul(a)).mmul(l)).getRow(r.derivative),i=1}else 1===r.derivative?(n=[-2,-1,0,1,2],i=10):(n=[2,-1,-2,-1,2],i=7);for(var f=i*Math.pow(e,r.derivative),m=o;m<t.length-o;m++){for(var g=0,d=0;d<n.length;d++)g+=n[d]*t[d+m-o]/f;s[m-o]=g}return"post"===r.pad&&(s=src$7(s,{size:o,value:r.padValue})),s}for(var src$8=SavitzkyGolay,ans=new Array(256),i=0;i<256;i++){for(var num=i,c=0;num;)num&=num-1,c++;ans[i]=c}var creator=ans;function count(t){for(var e=0,r=0;r<t.length;r++)e+=creator[255&t[r]]+creator[t[r]>>8&255]+creator[t[r]>>16&255]+creator[t[r]>>24&255];return e}function and(t,e){for(var r=new Array(t.length),n=0;n<t.length;n++)r[n]=t[n]&e[n];return r}function or(t,e){for(var r=new Array(t.length),n=0;n<t.length;n++)r[n]=t[n]|e[n];return r}function xor(t,e){for(var r=new Array(t.length),n=0;n<t.length;n++)r[n]=t[n]^e[n];return r}function not(t){for(var e=new Array(t.length),r=0;r<e.length;r++)e[r]=~t[r];return e}function getBit(t,e){var r=1<<31-e%32;return Boolean(t[e>>5]&r)}function setBit(t,e,r){var n=e>>5,i=1<<31-e%32;return t[n]=r?i|t[n]:~i&t[n],t}function toBinaryString(t){for(var e="",r=0;r<t.length;r++){var n=(t[r]>>>0).toString(2);e+="00000000000000000000000000000000".substr(n.length)+n}return e}function parseBinaryString(t){for(var e=t.length/32,r=new Array(e),n=0;n<e;n++)r[n]=0|parseInt(t.substr(32*n,32),2);return r}function toHexString(t){for(var e="",r=0;r<t.length;r++){var n=(t[r]>>>0).toString(16);e+="00000000".substr(n.length)+n}return e}function parseHexString(t){for(var e=t.length/8,r=new Array(e),n=0;n<e;n++)r[n]=0|parseInt(t.substr(8*n,8),16);return r}function toDebug(t){for(var e=toBinaryString(t),r="",n=0;n<t.length;n++){r+="0000".substr((32*n).toString(16).length)+(32*n).toString(16)+":";for(var i=0;i<32;i+=4)r+=" "+e.substr(32*n+i,4);n<t.length-1&&(r+="\n")}return r}var src$9={count:count,and:and,or:or,xor:xor,not:not,getBit:getBit,setBit:setBit,toBinaryString:toBinaryString,parseBinaryString:parseBinaryString,toHexString:toHexString,parseHexString:parseHexString,toDebug:toDebug};function mode$1(t){if(!src(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");for(var e=0,r=0,n=0,i={},o=0;o<t.length;++o){var s=t[o];(n=i[s])?(i[s]++,n++):i[s]=n=1,n>r&&(r=n,e=t[o])}return e}function norm$1(t){var e=(arguments.length>1&&void 0!==arguments[1]?arguments[1]:{}).algorithm,r=void 0===e?"absolute":e;if(!Array.isArray(t))throw new Error("input must be an array");if(0===t.length)throw new Error("input must not be empty");switch(r.toLowerCase()){case"absolute":var n=absoluteSum(t);return 0===n?t.slice(0):t.map(function(t){return t/n});default:throw new Error("norm: unknown algorithm: ".concat(r))}}function absoluteSum(t){for(var e=0,r=0;r<t.length;r++)e+=Math.abs(t[r]);return e}function _typeof(t){return(_typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function sequentialFill(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if("object"!==_typeof(t)||src(t)||(e=t,t=[]),!src(t))throw new TypeError("input must be an array");var r=e,n=r.from,i=void 0===n?0:n,o=r.to,s=void 0===o?10:o,a=r.size,h=void 0===a?t.length:a,c=r.step;if(h&&c)throw new Error("step is defined by the array size");if(h||(h=c?Math.floor((s-i)/c)+1:s-i+1),!c&&h&&(c=(s-i)/(h-1)),Array.isArray(t)){t.length=0;for(var u=0;u<h;u++)t.push(i),i+=c}else{if(t.length!==h)throw new Error("sequentialFill typed array must have the correct length");for(var l=0;l<h;l++)t[l]=i,i+=c}return t}function variance(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!src(t))throw new TypeError("input must be an array");for(var r=e.unbiased,n=void 0===r||r,i=e.mean,o=void 0===i?mean(t):i,s=0,a=0;a<t.length;a++){var h=t[a]-o;s+=h*h}return n?s/(t.length-1):s/t.length}function standardDeviation(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Math.sqrt(variance(t,e))}function mergeByCentroids(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const{window:n=.01}=r;for(var i={x:e.slice(),y:new Array(e.length).fill(0)},o=0,s=0;o<t.x.length&&s<e.length;){var a=t.x[o]-e[s];Math.abs(a)<n?i.y[s]+=t.y[o++]:a<0?o++:s++}return i}function closestX(t,e){const{x:r,y:n}=t,{target:i=r[0],reverse:o=!1}=e;let s;return(s=binarySearch(r,i,o?descending:ascending))>=0?{x:r[s],y:n[s]}:0!==(s=~s)&&Math.abs(r[s]-i)>.5||s===r.length?{x:r[s-1],y:n[s-1]}:{x:r[s],y:n[s]}}function maxMerge(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{x:r,y:n}=t,{groupWidth:i=.001}=e;for(var o={x:[],y:[]},s={x:[],y:[]},a=0,h=0;h<r.length;)0===a||r[h]-o.x[a-1]>i?(s.x.push(r[h]),s.y.push(n[h]),o.x.push(r[h]),o.y.push(n[h]),h++,a++):(n[h]>s.y[a-1]&&(s.x[a-1]=r[h],s.y[a-1]=n[h]),o.x[a-1]=r[h],o.y[a-1]+=n[h],h++);return o.x=s.x.slice(),o}function maxY(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{x:r,y:n}=t;let{from:i={index:0},to:o={index:r.length},reverse:s=!1}=e;void 0!==i.value&&void 0===i.index&&(i.index=calculateIndex(i.value,r,s)),void 0!==o.value&&void 0===o.index&&(o.index=calculateIndex(o.value,r,s));for(var a,h=Number.MIN_VALUE,c=i.index;c<o.index;c++)h<n[c]&&(h=n[c],a=c);return{index:a,value:h}}function calculateIndex(t,e,r){let n;if((n=binarySearch(e,t,r?descending:ascending))<0)throw new Error("the value ".concat(t," doesn't belongs to the abscissa value"));return n}function sortX(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{x:r,y:n}=t,{reverse:i=!1}=e;var o;o=i?(t,e)=>e.x-t.x:(t,e)=>t.x-e.x;for(var s=r.map((t,e)=>({x:t,y:n[e]})).sort(o),a={x:r.slice(),y:n.slice()},h=0;h<r.length;h++)a.x[h]=s[h].x,a.y[h]=s[h].y;return a}function uniqueX(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{x:e,y:r}=t;if(e.length<2)return;if(e.length!==r.length)throw new Error("The X and Y arrays mush have the same length");let n=e[0],i=0;for(let t=1;t<e.length;t++)n!==e[t]&&(i++,n=e[t],e[i]=e[t],t!==i&&(r[i]=0)),t!==i&&(r[i]+=r[t]);e.length=i+1,r.length=i+1}function weightedMerge(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{x:r,y:n}=t,{groupWidth:i=.001}=e;for(var o={x:[],y:[]},s={x:[],y:[]},a=0,h=0;h<r.length;)0===a||r[h]-o.x[a-1]>i?(s.x.push(r[h]*n[h]),s.y.push(n[h]),o.x.push(r[h]),o.y.push(n[h]),h++,a++):(s.x[a-1]+=r[h]*n[h],s.y[a-1]+=n[h],o.x[a-1]=r[h],o.y[a-1]+=n[h],h++);for(var c=0;c<o.x.length;c++)o.x[c]=s.x[c]/s.y[c];return o}function integral(t,e,r,n){return.5*r*e*e+n*e-(.5*r*t*t+n*t)}function equallySpacedSmooth(t,e,r,n,i){var o=t.length,s=(n-r)/(i-1),a=s/2,h=new Array(i),c=t[1]-t[0],u=t[o-1]-t[o-2],l=r-a,f=r+a,m=Number.MIN_VALUE,g=0,d=t[0]-c,p=0,w=0,v=0,x=0,y=0,M=0,b=0,S=0;t:for(;;){for(m<=l&&l<=d&&(y=w+(A=integral(0,l-m,v,g)));d-f>=0;){var A=integral(0,f-m,v,g);if(M=w+A,h[S++]=(M-y)/s,S===i)break t;l=f,f+=s,y=M}w+=integral(m,d,v,x),m=d,g=p,b<o?(d=t[b],p=e[b],b++):b===o&&(d+=u,p=0),x=-(v=(p-g)/(d-m))*m+g}return h}function equallySpacedSlot(t,e,r,n,i){var o=t.length,s=(n-r)/(i-1),a=s/2,h=t[t.length-1]-t[t.length-2],c=r-a,u=new Array(i),l=c,f=c+s,m=-Number.MAX_VALUE,g=0,d=t[0],p=e[0],w=0,v=!0,x=0,y=0,M=1,b=0;t:for(;;){if(m>=d)throw new Error("x must be an increasing serie");for(;m-f>0;){if(v&&(y++,v=!1),u[b]=y<=0?0:x/y,++b===i)break t;l=f,f+=s,x=0,y=0}m>l&&(x+=g,y++),(m===-Number.MAX_VALUE||w>1)&&y--,m=d,g=p,M<o?(d=t[M],p=e[M],M++):(d+=h,p=0,w++)}return u}function getZones(t,e,r){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[];t>e&&([t,e]=[e,t]),n=n.filter(t=>void 0!==t.from&&void 0!==t.to),(n=JSON.parse(JSON.stringify(n))).forEach(t=>{t.from>t.to&&([t.to,t.from]=[t.from,t.to])}),n.sort((t,e)=>t.from-e.from),n.forEach(r=>{r.from<t&&(r.from=t),r.to>e&&(r.to=e)});for(let t=0;t<n.length-1;t++)n[t].to>n[t+1].from&&(n[t].to=n[t+1].from);if(!(n=n.filter(t=>t.from<t.to))||0===n.length)return[{from:t,to:e,numberOfPoints:r}];let i=n.reduce((t,e)=>t+=e.to-e.from,0),o=(e-t-i)/r,s=[],a=t,h=0;for(let t of n){let e=Math.round((t.from-a)/o);h+=e,e>0&&s.push({from:a,to:t.from,numberOfPoints:e}),a=t.to}return r-h>0&&s.push({from:a,to:e,numberOfPoints:r-h}),s}function equallySpaced(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{x:r,y:n}=t,i=r.length,o=!1;r.length>1&&r[0]>r[1]&&(r=r.slice().reverse(),n=n.slice().reverse(),o=!0);let{from:s=r[0],to:a=r[i-1],variant:h="smooth",numberOfPoints:c=100,exclusions:u=[]}=e;if(i!==n.length)throw new RangeError("the x and y vector doesn't have the same size.");if("number"!=typeof s||isNaN(s))throw new RangeError("'from' option must be a number");if("number"!=typeof a||isNaN(a))throw new RangeError("'to' option must be a number");if("number"!=typeof c||isNaN(c))throw new RangeError("'numberOfPoints' option must be a number");let l=getZones(s,a,c,u),f=[],m=[];for(let t of l){let e=processZone(r,n,t.from,t.to,t.numberOfPoints,h);f.push(...e.x),m.push(...e.y)}return o?s<a?{x:f.reverse(),y:m.reverse()}:{x:f,y:m}:s<a?{x:f,y:m}:{x:f.reverse(),y:m.reverse()}}function processZone(t,e,r,n,i,o){if(i<1)throw new RangeError("the number of points must be at least 1");var s="slot"===o?equallySpacedSlot(t,e,r,n,i):equallySpacedSmooth(t,e,r,n,i);return{x:sequentialFill({from:r,to:n,size:i}),y:s}}function getZones$1(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];t>e&&([t,e]=[e,t]),r=r.filter(t=>void 0!==t.from&&void 0!==t.to),(r=JSON.parse(JSON.stringify(r))).forEach(t=>{t.from>t.to&&([t.to,t.from]=[t.from,t.to])}),r.sort((t,e)=>t.from-e.from),r.forEach(r=>{r.from<t&&(r.from=t),r.to>e&&(r.to=e)});for(let t=0;t<r.length-1;t++)r[t].to>r[t+1].from&&(r[t].to=r[t+1].from);if(!(r=r.filter(t=>t.from<t.to))||0===r.length)return[{from:t,to:e}];let n=[],i=t;for(let t of r)i<t.from&&n.push({from:i,to:t.from}),i=t.to;return i<e&&n.push({from:i,to:e}),n}function filterX(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{x:r,y:n}=t,{from:i=r[0],to:o=r[r.length-1],exclusions:s=[]}=e;let a=getZones$1(i,o,s),h=0,c=[],u=[],l=0;for(;l<r.length;){if(r[l]<=a[h].to&&r[l]>=a[h].from)c.push(r[l]),u.push(n[l]);else if(r[l]>a[h].to&&!a[++h])break;l++}return{x:c,y:u}}const{Matrix:Matrix$3,SVD:SVD,EVD:EVD,CholeskyDecomposition:CholeskyDecomposition$1,LuDecomposition:LuDecomposition$1,QrDecomposition:QrDecomposition$1}=MatrixLib,Array$1={min:min,max:max,median:median,mean:mean,mode:mode$1,normed:norm$1,rescale:rescale,sequentialFill:sequentialFill,standardDeviation:standardDeviation,variance:variance},ArrayXY={centroidsMerge:mergeByCentroids,closestX:closestX,maxMerge:maxMerge,maxY:maxY,sortX:sortX,uniqueX:uniqueX,weightedMerge:weightedMerge,equallySpaced:equallySpaced,filterX:filterX};exports.Array=Array$1,exports.ArrayXY=ArrayXY,exports.BitArray=src$9,exports.CholeskyDecomposition=CholeskyDecomposition$1,exports.ConfusionMatrix=src$2,exports.CrossValidation=src$4,exports.DecisionTreeClassifier=DecisionTreeClassifier,exports.DecisionTreeRegression=DecisionTreeRegression,exports.Distance=distances,exports.EVD=EVD,exports.ExponentialRegression=ExponentialRegression,exports.FNN=FeedForwardNeuralNetwork,exports.HClust=index,exports.HashTable=HashTable,exports.KMeans=kmeans,exports.KNN=KNN,exports.KOPLS=KOPLS,exports.Kernel=kernel,exports.LuDecomposition=LuDecomposition$1,exports.Matrix=Matrix$3,exports.MatrixLib=MatrixLib,exports.MultivariateLinearRegression=MultivariateLinearRegression,exports.NaiveBayes=index$1,exports.PCA=PCA,exports.PLS=PLS,exports.Performance=src$6,exports.PolynomialRegression=PolynomialRegression,exports.PowerRegression=PowerRegression,exports.QrDecomposition=QrDecomposition$1,exports.Random=Random,exports.RandomForestClassifier=RandomForestClassifier,exports.RandomForestRegression=RandomForestRegression,exports.RobustPolynomialRegression=RobustPolynomialRegression,exports.SOM=src$5,exports.SVD=SVD,exports.Similarity=similarities,exports.SimpleLinearRegression=SimpleLinearRegression,exports.SparseMatrix=SparseMatrix,exports.TheilSenRegression=TheilSenRegression,exports.XSadd=XSadd,exports.binarySearch=binarySearch,exports.distanceMatrix=src$1,exports.levenbergMarquardt=levenbergMarquardt,exports.numSort=index$2,exports.padArray=src$7,exports.savitzkyGolay=src$8,Object.defineProperty(exports,"__esModule",{value:!0})});
//# sourceMappingURL=ml.min.js.map
